<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Python," />





  <link rel="alternate" href="/atom.xml" title="野蛮生长 to 2018" type="application/atom+xml" />






<meta name="description" content="目前不懂的有：闭包、装饰器和生成器在python中，用方括号 ([]) 来表示列表，并用逗号来分隔其中的元素。12bicycles = [&apos;trek&apos;, &apos;cannondale&apos;, &apos;redline&apos;, &apos;specialized&apos;]print(bicycles) 如果你让Python将列表打印出来， Python将打印列表内的内部表示，包括方括号：1[&apos;trek&apos;, &apos;cannondale&apos;, &apos;">
<meta name="keywords" content="Python">
<meta property="og:type" content="article">
<meta property="og:title" content="Python编程基础篇">
<meta property="og:url" content="https://dwjie824.github.io/2018/05/28/Hello-Hexo/index.html">
<meta property="og:site_name" content="野蛮生长 to 2018">
<meta property="og:description" content="目前不懂的有：闭包、装饰器和生成器在python中，用方括号 ([]) 来表示列表，并用逗号来分隔其中的元素。12bicycles = [&apos;trek&apos;, &apos;cannondale&apos;, &apos;redline&apos;, &apos;specialized&apos;]print(bicycles) 如果你让Python将列表打印出来， Python将打印列表内的内部表示，包括方括号：1[&apos;trek&apos;, &apos;cannondale&apos;, &apos;">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-11-14T06:07:27.892Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python编程基础篇">
<meta name="twitter:description" content="目前不懂的有：闭包、装饰器和生成器在python中，用方括号 ([]) 来表示列表，并用逗号来分隔其中的元素。12bicycles = [&apos;trek&apos;, &apos;cannondale&apos;, &apos;redline&apos;, &apos;specialized&apos;]print(bicycles) 如果你让Python将列表打印出来， Python将打印列表内的内部表示，包括方括号：1[&apos;trek&apos;, &apos;cannondale&apos;, &apos;">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://dwjie824.github.io/2018/05/28/Hello-Hexo/"/>





  <title>Python编程基础篇 | 野蛮生长 to 2018</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">野蛮生长 to 2018</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录生活点滴</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dwjie824.github.io/2018/05/28/Hello-Hexo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongwj">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="野蛮生长 to 2018">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Python编程基础篇</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-28T12:32:28+08:00">
                2018-05-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="目前不懂的有：闭包、装饰器和生成器"><a href="#目前不懂的有：闭包、装饰器和生成器" class="headerlink" title="目前不懂的有：闭包、装饰器和生成器"></a>目前不懂的有：闭包、装饰器和生成器</h2><p>在python中，用方括号 ([]) 来表示列表，并用逗号来分隔其中的元素。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bicycles = [<span class="string">'trek'</span>, <span class="string">'cannondale'</span>, <span class="string">'redline'</span>, <span class="string">'specialized'</span>]</span><br><span class="line">print(bicycles)</span><br></pre></td></tr></table></figure></p>
<p>如果你让Python将列表打印出来， Python将打印列表内的内部表示，包括方括号：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'trek'</span>, <span class="string">'cannondale'</span>, <span class="string">'redline'</span>, <span class="string">'specialized'</span>]</span><br></pre></td></tr></table></figure></p>
<p>用索引来访问list中每一个位置的元素，记得索引是从0开始的：<br>正确方式<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(bicycles[<span class="number">0</span>])</span><br></pre></td></tr></table></figure></p>
<p>Python只返回该元素， 而不包括方括号和引号<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trek</span><br></pre></td></tr></table></figure></p>
<p>当索引超出了范围时，Python会报一个IndexError错误，所以，要确保索引不要越界，记得最后一个元素的索引是len(bicycles) - 1。<br>Python为访问最后一个列表元素提供了一个特殊语法。通过将索引指定为-1，可让Python返回最后一个列表元素：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(bicycles[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure></p>
<p>这种约定也适用于其他负数索引，例如：索引-2返回倒数第二个列表元素，索引-3返回倒数第三个列表元素，以此类推。<br>如果字符串里面有很多字符都需要转义，就需要加入很多<code>\</code>，为了简化，Python还允许使用<code>r&#39;&#39;</code>表示<code>&#39;&#39;</code><br>内部的字符串默认不转义，比如<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'\\\t\\'</span>)</span><br><span class="line">\	\</span><br><span class="line">&gt;&gt;&gt;print(<span class="string">r'\\\t\\'</span>)</span><br><span class="line">\\\t\\</span><br></pre></td></tr></table></figure></p>
<p>推荐<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431664106267f12e9bef7ee14cf6a8776a479bdec9b9000" target="_blank" rel="noopener">廖雪峰的官方网站–字符串和编码</a>,了解更多详情<br><a id="more"></a></p>
<h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><p>list元素也可以是另一个list，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = [&apos;python&apos;, &apos;java&apos;, [&apos;asp&apos;, &apos;php&apos;], &apos;scheme&apos;]</span><br><span class="line">&gt;&gt;&gt; len(s)</span><br><span class="line">4</span><br></pre></td></tr></table></figure></p>
<p>在列表末尾添加元素，使用.append()<br>在列表中插入元素，使用insert() ， 使用方法insert() 可在列表的任何位置添加新元素。<br>为此，你需要指定新元素的索引和值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">motorcycles=[<span class="string">'honda'</span>, <span class="string">'yamaha'</span>, <span class="string">'suzuki'</span>]</span><br><span class="line">motorcycles.insert(<span class="number">0</span>, <span class="string">'ducati'</span>)</span><br><span class="line">print(motorcycles)</span><br></pre></td></tr></table></figure></p>
<p>使用del语句删除元素<br>如果知道要删除的元素在列表中的位置，可使用del语句。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">motorcycles = [<span class="string">'honda'</span>, <span class="string">'yamaha'</span>, <span class="string">'suzuki'</span>]</span><br><span class="line"><span class="keyword">del</span> motorcycles[<span class="number">0</span>]</span><br><span class="line">print(motorcycles)</span><br></pre></td></tr></table></figure></p>
<p>方法pop() 可删除列表末尾的元素，并让你能够接着使用它。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">popped_motorcycle = motorcycles.pop()</span><br></pre></td></tr></table></figure></p>
<p>实际上可使用pop() 来删除列表中任何位置的元素，只需在括号中指定要删除的元素的索引即可。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">motorcycles = [<span class="string">'honda'</span>, <span class="string">'yamaha'</span>, <span class="string">'suzuki'</span>]</span><br><span class="line">fisrt_owned=motorcycles.pop(<span class="number">0</span>)</span><br><span class="line">print(<span class="string">'The first motorcycle I owned was a '</span> + first_owned.title() + <span class="string">'.'</span>)</span><br></pre></td></tr></table></figure></p>
<p>根据值删除元素，可使用方法remove()<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">motorcycles.remove(<span class="string">'ducati'</span>)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意： 方法remove() 只删除第一个指定的值。如果要删除的值可能在列表中出现多次，就需要使用循环来判断</p>
</blockquote>
<p>使用方法sort()对列表进行永久性排序<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cars = [<span class="string">'bmw'</span>, <span class="string">'audi'</span>, <span class="string">'toyota'</span>, <span class="string">'subaru'</span>]</span><br><span class="line">cars.sort()</span><br><span class="line">print(cars)</span><br></pre></td></tr></table></figure></p>
<p>向sort()方法传递参数reverse=True。就可以按与字母顺序相反的顺序排列列表元素。同样，对列表元素排列顺序的修改是永久性的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cars.sort(reverse=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure></p>
<p>使用函数sorted() 能够按特定顺序显示列表元素，同时不影响它们在列表中的原始排列顺序。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(sorted(cars))</span><br></pre></td></tr></table></figure></p>
<p>调用函数sorted() 后，列表元素的排列顺序并没有变。如果要按与字母顺序相反的顺序显示列表，也可向函数sorted()传递参数reverse=True。</p>
<p>要反转列表元素的排列顺序，可使用reverse()。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cars.reverse()</span><br></pre></td></tr></table></figure></p>
<p>方法reverse() 永久性地修改列表元素的排列顺序，但可随时恢复到原来的排列顺序，为此只需对列表再次调用reverse()即可。</p>
<p>使用for循环来打印魔术师名单中的所有名字：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">magicians = [<span class="string">'alice'</span>, <span class="string">'david'</span>, <span class="string">'carolina'</span>]</span><br><span class="line"><span class="keyword">for</span> magician <span class="keyword">in</span> magicians:</span><br><span class="line">	print(magician)</span><br></pre></td></tr></table></figure></p>
<p>在for循环中，想包含多少行代码都可以，每个缩进的代码行都是循环的一部分，而没有缩进的代码都只执行一次，不会重复执行。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">magicians = [<span class="string">'alice'</span>, <span class="string">'david'</span>, <span class="string">'carolina'</span>]</span><br><span class="line"><span class="keyword">for</span> magician <span class="keyword">in</span> magicians:</span><br><span class="line">	print(magician.title() + <span class="string">", that was a great trick!"</span>)</span><br><span class="line">	print(<span class="string">"I can't wait to see your trick,"</span> + magician.title() + <span class="string">".\n"</span>)</span><br><span class="line">print(<span class="string">"Thank you, everyone. That was a great magic show!"</span>)</span><br></pre></td></tr></table></figure></p>
<p>执行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Alice, that was a great trick!</span><br><span class="line">I can&apos;t wait to see your next trick, Alice.</span><br><span class="line"></span><br><span class="line">David, that was a great trick!</span><br><span class="line">I can&apos;t wait to see your next trick, Alice.</span><br><span class="line"></span><br><span class="line">Carolina, that was a great trick!</span><br><span class="line">I can&apos;t wait to see your next trick, Alice.</span><br><span class="line"></span><br><span class="line">Thank you,everyone. That was a great magic show!</span><br></pre></td></tr></table></figure></p>
<h2 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h2><p>如果你不小心缩进了无需缩进的代码行，Python将指出这一点：<br>hello_world.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">message = <span class="string">"Hello Python world!"</span></span><br><span class="line">	print(message)</span><br></pre></td></tr></table></figure></p>
<p>Python 将指出这种错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> File &quot;hello_world.py&quot;, line 2</span><br><span class="line"> 	print(message)</span><br><span class="line"> 	^</span><br><span class="line">IndentationError: unexpected indent</span><br></pre></td></tr></table></figure></p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>要打印数字1~5，需要使用range(1,6)<br>创建数字列表，可使用函数list() 将range() 的结果直接转换为列表。如果将range()作为list的参数，输出将为一个数字列表。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numbers=list(range(<span class="number">1</span>,<span class="number">6</span>))</span><br><span class="line">print(numbers)</span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,4,5]</span><br></pre></td></tr></table></figure></p>
<p>使用函数range()时，还可指定步长。例如：下面的代码打印1~10内的偶数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">even_numbers = list(range(<span class="number">2</span>,<span class="number">11</span>,<span class="number">2</span>))</span><br><span class="line">print(even_numbers)</span><br></pre></td></tr></table></figure></p>
<p>在这个示列中，函数range()从2开始数，然后不断加2，直到达到或超过终值(11),故输出为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2,4,6,8,10]</span><br></pre></td></tr></table></figure></p>
<p>使用列表解析创建平方数列表<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">squares = [values**<span class="number">2</span> <span class="keyword">for</span> value <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">11</span>)]</span><br><span class="line">print(squares)</span><br></pre></td></tr></table></figure></p>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>处理列表的部分元素–Python称之为切片<br>要创建切片，可指定要是使用的第一个元素和最后一个元素的索引。与函数range() 一样，Python在到达你指定的第二个索引前面的元素后停止。<br>要输出列表中的前三个元素，需要指定索引0~3，这将输出分别为0、1和2的这3个元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">players = [&apos;charles&apos;, &apos;martina&apos;, &apos;michael&apos;, &apos;florence&apos;, &apos;eli&apos;]</span><br><span class="line">print(players[0:3])</span><br><span class="line">print(players[:4])</span><br><span class="line">print(players[2:])</span><br></pre></td></tr></table></figure></p>
<p>如果要输出名单上的最后三名队员，可使用切片players[-3:]<br>要复制列表，可创建一个包含整个列表的切片，方法是同时省略起始索引和终止索引([:])。区别于关联。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">my_foods = [<span class="string">'pizza'</span>, <span class="string">'falafel'</span>, <span class="string">'carrot cake'</span>]</span><br><span class="line">friend_foods=my_foods[:]</span><br><span class="line">my_foods.append(<span class="string">'cannoli'</span>)</span><br><span class="line">friend_foods.append(<span class="string">'ice cream'</span>)</span><br><span class="line">print(<span class="string">"My favorite foods are："</span>)</span><br><span class="line">print(my_foods)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"\nMy friend's favorite foods are:"</span>)</span><br><span class="line">print(friend_foods)</span><br></pre></td></tr></table></figure></p>
<p>在不使用切片的情况下复制列表的情况：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">my_foods = [<span class="string">'pizza'</span>, <span class="string">'falafel'</span>, <span class="string">'carrot cake'</span>]</span><br><span class="line"><span class="comment">#这行不通</span></span><br><span class="line">friend_foods=my_foods</span><br><span class="line">my_foods.append(<span class="string">'cannoli'</span>)</span><br><span class="line">friend_foods.append(<span class="string">'ice cream'</span>)</span><br><span class="line">print(<span class="string">"My favorite foods are："</span>)</span><br><span class="line">print(my_foods)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"\nMy friend's favorite foods are:"</span>)</span><br><span class="line">print(friend_foods)</span><br></pre></td></tr></table></figure></p>
<p>这里是将my_foods赋给friend_foods，而不是将my_foods的副本存储到friend_foods。实际这两个变量都指向同一个列表。<br>如果把切片放在赋值语句的左边，或把它作为del操作的对象，我们就可以对序列进行嫁接、切除或就地修改操作。<br>通过下面几个例子，你应该就能体会到这些操作的强大功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; l = list(range(10))</span><br><span class="line">&gt;&gt;&gt; 1</span><br><span class="line">[0,1,2,3,4,5,6,7,8,9]</span><br><span class="line">&gt;&gt;&gt; l[2:5]=[20, 30]</span><br><span class="line">&gt;&gt;&gt; l</span><br><span class="line">[0,1,20,30,5,6,7,8,9]</span><br><span class="line">&gt;&gt;&gt; del l[5:7]</span><br><span class="line">&gt;&gt;&gt; l</span><br><span class="line">[0,1,20,30,5,8,9]</span><br><span class="line">&gt;&gt;&gt; l[3:2]=[11,22]</span><br><span class="line">&gt;&gt;&gt; l</span><br><span class="line">[0,1,20,11,5,22,9]</span><br></pre></td></tr></table></figure></p>
<h2 id="对序列使用-和"><a href="#对序列使用-和" class="headerlink" title="对序列使用+和*"></a>对序列使用+和*</h2><p>如果想要把一个序列复制几份然后再拼接起来，更快捷的做法是把这个序列乘以一个整数。同样<br>这个操作会产生一个新序列：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; l = [1,2,3]</span><br><span class="line">&gt;&gt;&gt; l * 5</span><br><span class="line">[1,2,3,1,2,3,1,2,3,1,2,3,1,2,3]</span><br><span class="line">&gt;&gt;&gt;5 * &apos;abcd&apos;</span><br><span class="line">&apos;abcdabcdabcdabcdabcd&apos;</span><br></pre></td></tr></table></figure></p>
<p>+和<em>都遵循这个规律，不修改原有的操作对象，而是构建一个全新的序列。<br>下面来看看如何用</em>来初始化一个由列表组成的列表<br>一个包含3个列表的列表，嵌套的3个列表各自有3个元素来代表井字游戏的一行方块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; board = [[&apos;_&apos;]*3 for i in range(3)]</span><br><span class="line">&gt;&gt;&gt; board</span><br><span class="line">[[&apos;_&apos;,&apos;_&apos;,&apos;_&apos;],[&apos;_&apos;,&apos;_&apos;,&apos;_&apos;],[&apos;_&apos;,&apos;_&apos;,&apos;_&apos;]]</span><br><span class="line">&gt;&gt;&gt; board[1][2] =&apos;X&apos;</span><br><span class="line">&gt;&gt;&gt; board</span><br><span class="line">[[&apos;_&apos;,&apos;_&apos;,&apos;_&apos;],[&apos;_&apos;,&apos;_&apos;,&apos;X&apos;],[&apos;_&apos;,&apos;_&apos;,&apos;_&apos;]]</span><br></pre></td></tr></table></figure></p>
<p>现在展示另一个方法，然而含有3个指向同一个对象的引用的列表是毫无用处的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; weird_board = [[&apos;_&apos;]*3]*3</span><br><span class="line">&gt;&gt;&gt; weird_board</span><br><span class="line">[[&apos;_&apos;,&apos;_&apos;,&apos;_&apos;],[&apos;_&apos;,&apos;_&apos;,&apos;_&apos;],[&apos;_&apos;,&apos;_&apos;,&apos;_&apos;]]</span><br><span class="line">&gt;&gt;&gt; weird_board[1][2]=&apos;0&apos;</span><br><span class="line">&gt;&gt;&gt; weird_board</span><br><span class="line">[[&apos;_&apos;,&apos;_&apos;,&apos;0&apos;],[&apos;_&apos;,&apos;_&apos;,&apos;0&apos;],[&apos;_&apos;,&apos;_&apos;,&apos;0&apos;]]</span><br></pre></td></tr></table></figure></p>
<p>外面的列表其实包含3个指向同一个列表的引用。当我们不做修改的时候看起来还好。<br>一旦我们试图标记第1行第2列的元素，就立马暴露了列表内的3个引用指向同一个对象的事实。<br>下面犯的错误本质上跟上面代码犯的错误一样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">row=[&apos;_&apos;]*3</span><br><span class="line">board=[]</span><br><span class="line">for i in range(3):</span><br><span class="line">	board.append(row)</span><br></pre></td></tr></table></figure></p>
<p>第一个例子的方法等同于这样做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;board=[]</span><br><span class="line">&gt;&gt;&gt;for i in range(3):</span><br><span class="line">		row[&apos;_&apos;] * 3</span><br><span class="line">		board.append(row)</span><br><span class="line">&gt;&gt;&gt;board</span><br><span class="line">[[&apos;_&apos;,&apos;_&apos;,&apos;_&apos;],[&apos;_&apos;,&apos;_&apos;,&apos;_&apos;],[&apos;_&apos;,&apos;_&apos;,&apos;_&apos;]]</span><br><span class="line">&gt;&gt;&gt;board[2][0]=&apos;X&apos;</span><br><span class="line">&gt;&gt;&gt;board</span><br><span class="line">[[&apos;_&apos;,&apos;_&apos;,&apos;_&apos;],[&apos;_&apos;,&apos;_&apos;,&apos;_&apos;],[&apos;X&apos;,&apos;_&apos;,&apos;_&apos;]]</span><br></pre></td></tr></table></figure></p>
<p>每次迭代中都新建了一个列表，作为新的一行追加到board。</p>
<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>Python将不能修改的值称为不可变的，而不可变的列表被称为元组。<br>元组看起来犹如列表，但使用圆括号而不是方括号来标识。<br>任何试图修改元组的操作是被禁止的，因此python指出不能给元组的元素赋值。<br>虽然不能修改元组的元素，但可以给存储元组的变量赋值。比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dimensions =(<span class="number">200</span>, <span class="number">50</span>)</span><br><span class="line">print(<span class="string">"Original dimensions:"</span>)</span><br><span class="line"><span class="keyword">for</span> dimension <span class="keyword">in</span> dimensions:</span><br><span class="line">	print(dimension)</span><br><span class="line">	</span><br><span class="line"><span class="comment">#dimensions[0] =400 #Python返回类型错误消息</span></span><br><span class="line">dimensions = (<span class="number">400</span>, <span class="number">100</span>) <span class="comment">#给元组变量赋值是合法的</span></span><br><span class="line">print(<span class="string">"\nModified dimensions:"</span>)</span><br><span class="line"><span class="keyword">for</span> dimension <span class="keyword">in</span> dimensions:</span><br><span class="line">	print(dimension)</span><br></pre></td></tr></table></figure></p>
<p>当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (1, 2)</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">(1, 2)</span><br></pre></td></tr></table></figure></p>
<p>如果要定义一个空的tuple，可以写成()：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = ()</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">()</span><br></pre></td></tr></table></figure></p>
<p>但是，要定义一个只有1个元素的tuple，如果你这么定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (1)</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p>
<p>定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，<br>因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是1。<br>所以，只有1个元素的tuple定义时必须加一个逗号,，来消除歧义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (1,)</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">(1,)</span><br></pre></td></tr></table></figure></p>
<p>Python在显示只有1个元素的tuple时，也会加一个逗号,，以免你误解成数学计算意义上的括号。</p>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>在Python中，字典是用放在花括号{}中的一系列键-值对表示。如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alien_0 = &#123;<span class="string">'color'</span>: <span class="string">'green'</span>, <span class="string">'points'</span>:<span class="number">5</span>&#125;</span><br><span class="line">print(alien_0[<span class="string">'color'</span>])</span><br><span class="line">print(alien_0)</span><br><span class="line">alien_0[<span class="string">'x_position'</span>] = <span class="number">0</span></span><br><span class="line">alien_0[<span class="string">'y_position'</span>] = <span class="number">25</span></span><br><span class="line">print(alien_0)</span><br></pre></td></tr></table></figure></p>
<p>显示结果为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">green</span><br><span class="line">&#123;<span class="string">'color'</span>:<span class="string">'green'</span>, <span class="string">'points'</span>:<span class="number">5</span>&#125;</span><br><span class="line">&#123;<span class="string">'color'</span>:<span class="string">'green'</span>, <span class="string">'points'</span>:<span class="number">5</span>, <span class="string">'y_position'</span>:<span class="number">25</span>, <span class="string">'x_position'</span>:<span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意：键-值对的排列顺序与添加顺序不同，Python不关心键-值对的添加顺序，而只关心键和值之间的关联关系。<br>对于字典中不再需要的信息，可使用del语句将相应的键-值对彻底删除。使用del语句时，必须指定字典名和要删除的键。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del alien_0[&apos;color&apos;]</span><br></pre></td></tr></table></figure></p>
<p>字典存储的时一个对象的多种信息，也可以使用字典来存储众多对象的同一种信息。假设要调查的是喜欢的编程语言<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">favorite_languages =&#123;</span><br><span class="line">	<span class="string">'jen'</span>:<span class="string">'python'</span>,</span><br><span class="line">	<span class="string">'sarah'</span>:<span class="string">'c'</span>,</span><br><span class="line">	<span class="string">'edward'</span>:<span class="string">'ruby'</span>,</span><br><span class="line">	<span class="string">'phil'</span>:<span class="string">'python'</span>,</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果key不存在，dict就会报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d[&apos;Thomas&apos;]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">KeyError: &apos;Thomas&apos;</span><br></pre></td></tr></table></figure></p>
<p>要避免key不存在的错误，有两种办法，一是通过in判断key是否存在：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;Thomas&apos; in d</span><br><span class="line">False</span><br></pre></td></tr></table></figure></p>
<p>二是通过dict提供的get()方法，如果key不存在，可以返回None，或者自己指定的value：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d.get(&apos;Thomas&apos;)</span><br><span class="line">&gt;&gt;&gt; d.get(&apos;Thomas&apos;, -1)</span><br><span class="line">-1</span><br></pre></td></tr></table></figure></p>
<p>注意：返回None的时候Python的交互环境不显示结果。<br>注意，在最后一个键-值对后面可加可不加逗号。<br>在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; key = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; d[key] = &apos;a list&apos;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: unhashable type: &apos;list&apos;</span><br></pre></td></tr></table></figure></p>
<p>方法items()返回一个键-值对列表，利用它可用于遍历字典。<br>方法keys()返回字典中的键，方法values()返回字典中的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">user_0 = &#123;</span><br><span class="line">	<span class="string">'username'</span>:<span class="string">'efermi'</span>,</span><br><span class="line">	<span class="string">'first'</span>:<span class="string">'enrico'</span>,</span><br><span class="line">	<span class="string">'last'</span>:<span class="string">'efermi'</span>,</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> user_0.items():</span><br><span class="line">	print(<span class="string">"\nKey:"</span> + key)</span><br><span class="line">	print(<span class="string">"Value:"</span> + value)</span><br></pre></td></tr></table></figure>
<p>在使用方法values()过程中可能包含大量的重复值，为剔除重复项，可使用集合（set）。<br>集合类似于列表，但每个元素都必须时独一无二的：<br>favorite_languages={<br>    ‘jen’:’python’,<br>    ‘sarah’:’c’,<br>    ‘edward’:’ruby’,<br>    ‘phil’:’python’,<br>    }<br>print(“The following languages have been mentioned:”)<br>for language in set(favorite_languages.values()):<br>    print(language.title())</p>
<p>set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s1 = set([1, 2, 3])</span><br><span class="line">&gt;&gt;&gt; s2 = set([2, 3, 4])</span><br><span class="line">&gt;&gt;&gt; s1 &amp; s2</span><br><span class="line">&#123;2, 3&#125;</span><br><span class="line">&gt;&gt;&gt; s1 | s2</span><br><span class="line">&#123;1, 2, 3, 4&#125;</span><br></pre></td></tr></table></figure></p>
<p>set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，<br>因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。试试把list放入set，看看是否会报错。</p>
<h2 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h2><p>列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。<br>举个例子，要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]可以用list(range(1, 11))：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(range(<span class="number">1</span>, <span class="number">11</span>))</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure></p>
<p>但如果要生成[1x1, 2x2, 3x3, …, 10x10]怎么做？方法一是循环：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">	    L.append(x * x)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure></p>
<p>但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure></p>
<p>写列表生成式时，把要生成的元素x * x放到前面，后面跟for循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。<br>for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">[<span class="number">4</span>, <span class="number">16</span>, <span class="number">36</span>, <span class="number">64</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure></p>
<p>还可以使用两层循环，可以生成全排列：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[m + n <span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">'ABC'</span> <span class="keyword">for</span> n <span class="keyword">in</span> <span class="string">'XYZ'</span>]</span><br><span class="line">[<span class="string">'AX'</span>, <span class="string">'AY'</span>, <span class="string">'AZ'</span>, <span class="string">'BX'</span>, <span class="string">'BY'</span>, <span class="string">'BZ'</span>, <span class="string">'CX'</span>, <span class="string">'CY'</span>, <span class="string">'CZ'</span>]</span><br></pre></td></tr></table></figure></p>
<p>三层和三层以上的循环就很少用到了。<br>运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现：</p>
<blockquote>
<blockquote>
<blockquote>
<p>import os # 导入os模块，模块的概念后面讲到<br>[d for d in os.listdir(‘.’)] # os.listdir可以列出文件和目录<br>[‘.emacs.d’, ‘.ssh’, ‘.Trash’, ‘Adlm’, ‘Applications’, ‘Desktop’, ‘Documents’, ‘Downloads’, ‘Library’, ‘Movies’, ‘Music’, ‘Pictures’, ‘Public’, ‘VirtualBox VMs’, ‘Workspace’, ‘XCode’]<br>for循环其实可以同时使用两个甚至多个变量，比如dict的items()可以同时迭代key和value：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'x'</span>: <span class="string">'A'</span>, <span class="string">'y'</span>: <span class="string">'B'</span>, <span class="string">'z'</span>: <span class="string">'C'</span> &#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k, v <span class="keyword">in</span> d.items():</span><br><span class="line">     print(k, <span class="string">'='</span>, v)</span><br><span class="line"></span><br><span class="line">y = B</span><br><span class="line">x = A</span><br><span class="line">z = C</span><br></pre></td></tr></table></figure></p>
</blockquote>
</blockquote>
</blockquote>
<p>因此，列表生成式也可以使用两个变量来生成list：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'x'</span>: <span class="string">'A'</span>, <span class="string">'y'</span>: <span class="string">'B'</span>, <span class="string">'z'</span>: <span class="string">'C'</span> &#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[k + <span class="string">'='</span> + v <span class="keyword">for</span> k, v <span class="keyword">in</span> d.items()]</span><br><span class="line">[<span class="string">'y=B'</span>, <span class="string">'x=A'</span>, <span class="string">'z=C'</span>]</span><br></pre></td></tr></table></figure></p>
<p>最后把一个list中所有的字符串变成小写：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="string">'Hello'</span>, <span class="string">'World'</span>, <span class="string">'IBM'</span>, <span class="string">'Apple'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[s.lower() <span class="keyword">for</span> s <span class="keyword">in</span> L]</span><br><span class="line">[<span class="string">'hello'</span>, <span class="string">'world'</span>, <span class="string">'ibm'</span>, <span class="string">'apple'</span>]</span><br></pre></td></tr></table></figure></p>
<h2 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建一个用于存储外星人的空列表</span></span><br><span class="line">aliens = []</span><br><span class="line"><span class="comment">#创建30个绿色的外星人</span></span><br><span class="line"><span class="keyword">for</span> alien_number <span class="keyword">in</span> range(<span class="number">30</span>):</span><br><span class="line">	new_alien = &#123;<span class="string">'color'</span>:<span class="string">'green'</span>,<span class="string">'points'</span>:<span class="number">5</span>,<span class="string">'speed'</span>:<span class="string">'slow'</span>&#125;</span><br><span class="line">	alien.append(new_alien)</span><br><span class="line"><span class="comment">#显示前五名外星人</span></span><br><span class="line"><span class="keyword">for</span> alien <span class="keyword">in</span> aliens[:<span class="number">5</span>]</span><br><span class="line">	print(alien)</span><br><span class="line">print(<span class="string">"..."</span>)</span><br><span class="line"><span class="comment">#显示创建了多少个外星人</span></span><br><span class="line">print(<span class="string">"Total number of aliens:"</span> + str(len(aliens)))</span><br></pre></td></tr></table></figure>
<p>显示结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;&apos;speed&apos;:&apos;slow&apos;,&apos;color&apos;:&apos;green&apos;,&apos;points&apos;:5&#125;</span><br><span class="line">&#123;&apos;speed&apos;:&apos;slow&apos;,&apos;color&apos;:&apos;green&apos;,&apos;points&apos;:5&#125;</span><br><span class="line">&#123;&apos;speed&apos;:&apos;slow&apos;,&apos;color&apos;:&apos;green&apos;,&apos;points&apos;:5&#125;</span><br><span class="line">&#123;&apos;speed&apos;:&apos;slow&apos;,&apos;color&apos;:&apos;green&apos;,&apos;points&apos;:5&#125;</span><br><span class="line">&#123;&apos;speed&apos;:&apos;slow&apos;,&apos;color&apos;:&apos;green&apos;,&apos;points&apos;:5&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Total number of aliens: 30</span><br></pre></td></tr></table></figure></p>
<p>在字典中存储列表，下面的示列中，存储了比萨的两方面信息：外皮类型和配料列表。其中的配料列表是一个与键’toopings’相关联的值。<br>要访问该列表，我们使用字典名和键’toppings’，就像访问字典中的其他值一样。这将返回一个配料列表，而不是单个值：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#存储所点比萨的信息</span></span><br><span class="line">pizza = &#123;</span><br><span class="line">	<span class="string">'crust'</span>:<span class="string">'thick'</span>,</span><br><span class="line">	<span class="string">'toppings'</span>:[<span class="string">'mushrooms'</span>,<span class="string">'extra cheese'</span>],</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">#概述所点的比萨</span></span><br><span class="line">print(<span class="string">"You ordered a "</span> + pizza[<span class="string">'crust'</span>] + <span class="string">"-crust pizza "</span> + <span class="string">"with the following toppings:"</span>)</span><br><span class="line"><span class="keyword">for</span> topping <span class="keyword">in</span> pizza[<span class="string">'toppings'</span>]<span class="string">"</span></span><br><span class="line"><span class="string">	print("</span>\t<span class="string">" + topping)</span></span><br></pre></td></tr></table></figure></p>
<p>下面的输出概述了要制作的比萨：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">You ordered a thick-crust pizza with the following toppings:</span><br><span class="line">	mushrooms</span><br><span class="line">	extra cheese</span><br></pre></td></tr></table></figure></p>
<p>在字典中存储字典<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">users =&#123;</span><br><span class="line">	<span class="string">'aeinstein'</span>:&#123;</span><br><span class="line">		<span class="string">'first'</span>:<span class="string">'albert'</span>,</span><br><span class="line">		<span class="string">'last'</span>:<span class="string">'einstein'</span>,</span><br><span class="line">		<span class="string">'location'</span>:<span class="string">'princeton'</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	<span class="string">'mcurie'</span>:&#123;</span><br><span class="line">		<span class="string">'first'</span>:<span class="string">'marie'</span>,</span><br><span class="line">		<span class="string">'last'</span>:<span class="string">'curie'</span>,</span><br><span class="line">		<span class="string">'location'</span>:<span class="string">'paris'</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">for</span> username,user_info <span class="keyword">in</span> users.items():</span><br><span class="line">	print(<span class="string">"\nUsername:"</span>+username)</span><br><span class="line">	full_name=user_info[<span class="string">'first'</span>]+user_info[<span class="string">'last'</span>]</span><br><span class="line">	location=user_info[<span class="string">'location'</span>]</span><br><span class="line">	</span><br><span class="line">	print(<span class="string">"\tFull name:"</span>+full_name.title())</span><br><span class="line">	print(<span class="string">"\tLocation:"</span>+location.title())</span><br></pre></td></tr></table></figure></p>
<h2 id="输入和循环"><a href="#输入和循环" class="headerlink" title="输入和循环"></a>输入和循环</h2><p>函数input()让程序暂停运行，等待用户输入一些文本。获取用户输入后，Python将其存储在一个变量中，以方便你使用。<br>假设你有一个宠物列表，其中包含多个值为’cat’的元素。要删除所有这些元素，可不断运行一个while循环，直到列表中不再包含值’cat’。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pets=[<span class="string">'dog'</span>,<span class="string">'cat'</span>,<span class="string">'dog'</span>,<span class="string">'goldfish'</span>,<span class="string">'cat'</span>,<span class="string">'rabbit'</span>,<span class="string">'cat'</span>]</span><br><span class="line">print(pets)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="string">'cat'</span> <span class="keyword">in</span> pets:</span><br><span class="line">	pets.remove(<span class="string">'cat'</span>)</span><br><span class="line">print(pets)</span><br></pre></td></tr></table></figure></p>
<h2 id="用bisect来管理已排序的序列"><a href="#用bisect来管理已排序的序列" class="headerlink" title="用bisect来管理已排序的序列"></a>用bisect来管理已排序的序列</h2><p>bisect模块包含两个主要函数，bisect和insort,两个函数都利用二分查找算法来在有序序列中查找或插入元素。</p>
<h3 id="用bisect来搜索"><a href="#用bisect来搜索" class="headerlink" title="用bisect来搜索"></a>用bisect来搜索</h3><p>bisect(haystack, needle) 在 haystack（干草垛）里搜索needle（针）的位置，该位置满足的条件是，把 needle 插入这个位置之后，<br>haystack 还能保持升序。也就是在说这个函数返回的位置前面的值，都小于或等于 needle 的值。其中 haystack 必须是一个有序的<br>序列。你可以先用bisect(haystack, needle) 查找位置 index，再用 haystack.insert(index, needle) 来插入新值。但你也可用insort<br>来一步到位，并且后者的速度更快一些。<br>bisect 可以用来建立一个用数字作为索引的查询表格，比如说把分数和成绩对应起来，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def grade(score, breakpoints=[60, 70, 80, 90], grades=&apos;FDCBA&apos;):</span><br><span class="line">... i = bisect.bisect(breakpoints, score)</span><br><span class="line">... return grades[i]</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; [grade(score) for score in [33, 99, 77, 70, 89, 90, 100]]</span><br><span class="line">[&apos;F&apos;, &apos;A&apos;, &apos;C&apos;, &apos;C&apos;, &apos;B&apos;, &apos;A&apos;, &apos;A&apos;]</span><br></pre></td></tr></table></figure></p>
<h3 id="用bissect-insort插入新元素"><a href="#用bissect-insort插入新元素" class="headerlink" title="用bissect.insort插入新元素"></a>用bissect.insort插入新元素</h3><p>insort(seq, item) 把变量 item 插入到序列 seq 中，并能保持 seq的升序顺序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import bisect</span><br><span class="line">import random</span><br><span class="line">SIZE=7</span><br><span class="line">random.seed(1729)</span><br><span class="line">my_list = []</span><br><span class="line">for i in range(SIZE):</span><br><span class="line">	new_item = random.randrange(SIZE*2)</span><br><span class="line">	bisect.insort(my_list, new_item)</span><br><span class="line">	print(&apos;%2d -&gt;&apos; % new_item, my_list)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">10 -&gt; [10]</span><br><span class="line"> 0 -&gt; [0,10]</span><br><span class="line"> 6 -&gt; [0,6,10]</span><br><span class="line"> 8 -&gt; [0,6,8,10]</span><br><span class="line"> 7 -&gt; [0,6,7,8,10]</span><br><span class="line"> 2 -&gt; [0,2,6,7,8,10]</span><br><span class="line">10 -&gt; [0,2,6,7,8,10,10]</span><br></pre></td></tr></table></figure></p>
<p>insort 跟 bisect 一样，有 lo 和 hi 两个可选参数用来控制查找的范围。它也有个变体叫 insort_left，这个变体在背后用的是bisect_left。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>定义函数，比如名为greet_user():<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def greet_user():</span><br><span class="line">	&quot;&quot;&quot;显示简单的问候语&quot;&quot;&quot;</span><br><span class="line">	print(&quot;Hello!&quot;)</span><br><span class="line"></span><br><span class="line">greet_user()</span><br></pre></td></tr></table></figure></p>
<p>这个示例演示了最简单的函数构造。关键字def告诉python你要定义一个函数。<br>在这里，函数名为greet_user(),它不需要任何信息就能完成其工作，因此括号是空的。最后，定义以冒号结尾。<br>紧跟在def greet_user():后面的所有缩进行构成了函数体。<br>文档字符串用三引号括起，用来生成有关程序中函数的文档。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">describe_pet</span><span class="params">(animal_type,pet_name)</span>:</span></span><br><span class="line">	<span class="string">"""显示宠物的信息"""</span></span><br><span class="line">	print(<span class="string">"\nI have a "</span>+animal_type+<span class="string">"."</span>)</span><br><span class="line">	print(<span class="string">"My "</span>+animal_type + <span class="string">"'s name is "</span>+ pet_name.title()+<span class="string">"."</span>)</span><br><span class="line">	describe_pet(<span class="string">'harry'</span>,<span class="string">'hamster'</span>)   <span class="comment">#位置实参</span></span><br><span class="line">	describe_pet(animal_type=<span class="string">'hamster'</span>, pet_name=<span class="string">'harry'</span>)  <span class="comment">#关键字实参</span></span><br></pre></td></tr></table></figure></p>
<p>注意，使用默认值时，在形参列表中必须先列出没有默认值的形参，再列出有默认值的实参。<br>函数可返回任何类型的值，包括列表和字典等教复杂的数据结构。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_person</span><span class="params">(first_name, last_name)</span>:</span></span><br><span class="line">	<span class="string">"""返回一个字典，其中包含有关一个人的信息"""</span></span><br><span class="line">	person = &#123;<span class="string">'fist'</span>:first_name,<span class="string">'last'</span>:last_name&#125;</span><br><span class="line">	<span class="keyword">return</span> person</span><br><span class="line"></span><br><span class="line">musician = build_person(<span class="string">'jimi'</span>,<span class="string">'hendrix'</span>)</span><br><span class="line">print(musician)</span><br></pre></td></tr></table></figure></p>
<p>向函数传递列表<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet_users</span><span class="params">(names)</span>:</span></span><br><span class="line">	<span class="string">"""向列表中的每位用户都发出简单的问候"""</span></span><br><span class="line">	<span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">		msg=<span class="string">"Hello, "</span>+ name.title() + <span class="string">"!"</span></span><br><span class="line">		print(msg)</span><br><span class="line"></span><br><span class="line">usernames=[<span class="string">'hahah'</span>,<span class="string">'ty'</span>,<span class="string">'margot'</span>]</span><br><span class="line">greet_users(usernames)</span><br></pre></td></tr></table></figure></p>
<p>禁止函数修改列表，可向函数传递列表的副本而不是原件，即切片表示法[:]创建列表的副本。<br>如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function_name(list_name[:])</span><br></pre></td></tr></table></figure></p>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>在Python函数中，可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。<br>我们以数学题为例子，给定一组数字a，b，c……，请计算a2 + b2 + c2 + ……。<br>要定义出这个函数，我们必须确定输入的参数。由于参数个数不确定，我们首先想到可以把a，b，c……作为一个list或tuple传进来，<br>这样，函数可以定义如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(numbers)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        sum = sum + n * n</span><br><span class="line">    <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure></p>
<p>但是调用的时候，需要先组装出一个list或tuple：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; calc([1, 2, 3])</span><br><span class="line">14</span><br><span class="line">&gt;&gt;&gt; calc((1, 3, 5, 7))</span><br><span class="line">84</span><br></pre></td></tr></table></figure></p>
<p>如果利用可变参数，调用函数的方式可以简化成这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; calc(1, 2, 3)</span><br><span class="line">14</span><br><span class="line">&gt;&gt;&gt; calc(1, 3, 5, 7)</span><br><span class="line">84</span><br></pre></td></tr></table></figure></p>
<p>所以，我们把函数的参数改为可变参数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(*numbers)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        sum = sum + n * n</span><br><span class="line">    <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure></p>
<p>定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号。<br>在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。<br>但是，调用该函数时，可以传入任意个参数，包括0个参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; calc(1, 2)</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; calc()</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p>
<p>如果已经有一个list或者tuple，要调用一个可变参数怎么办？可以这样做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; nums = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; calc(nums[0], nums[1], nums[2])</span><br><span class="line">14</span><br></pre></td></tr></table></figure></p>
<p>这种写法当然是可行的，问题是太繁琐，所以Python允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; nums = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; calc(*nums)</span><br><span class="line">14</span><br></pre></td></tr></table></figure></p>
<p>*nums表示把nums这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见。</p>
<h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>如果要让函数接受不同类型的实参，必须在函数定义中将接纳任意数量实参的形参放在最后。<br>Python先匹配位置实参和关键字实参，再将余下的实参都收集到最后一个形参中。<br>使用任意数量的关键字实参（注意区别于任意数量的实参）,即将函数编写成能够接受任意数量的键-值对。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_profile</span><span class="params">(fisrt,last,**user_info)</span>:</span></span><br><span class="line">	<span class="string">"""创建一个字典，其中包含我们知道的有关用户的一切"""</span></span><br><span class="line">	profile=&#123;&#125;</span><br><span class="line">	profile[<span class="string">'first_name'</span>]=first</span><br><span class="line">	profile[<span class="string">''</span>last_name<span class="string">']=last</span></span><br><span class="line"><span class="string">	for key,value in user_info.items():</span></span><br><span class="line"><span class="string">		profile[key]=value</span></span><br><span class="line"><span class="string">	return profile</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">user_profile=build_profile('</span>albert<span class="string">','</span>einstein<span class="string">',location='</span>princeton<span class="string">',field='</span>physics<span class="string">')</span></span><br><span class="line"><span class="string">print(user_profile)</span></span><br></pre></td></tr></table></figure></p>
<h3 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h3><p>如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下：<br>def person(name, age, <em>, city, job):<br>    print(name, age, city, job)<br>和关键字参数**kw不同，命名关键字参数需要一个特殊分隔符</em>，*后面的参数被视为命名关键字参数。<br>调用方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; person(&apos;Jack&apos;, 24, city=&apos;Beijing&apos;, job=&apos;Engineer&apos;)</span><br><span class="line">Jack 24 Beijing Engineer</span><br></pre></td></tr></table></figure></p>
<p>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, *args, city, job)</span>:</span></span><br><span class="line">    print(name, age, args, city, job)</span><br></pre></td></tr></table></figure></p>
<p>命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; person(&apos;Jack&apos;, 24, &apos;Beijing&apos;, &apos;Engineer&apos;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: person() takes 2 positional arguments but 4 were given</span><br></pre></td></tr></table></figure></p>
<p>由于调用时缺少参数名city和job，Python解释器把这4个参数均视为位置参数，但person()函数仅接受2个位置参数。<br>命名关键字参数可以有缺省值，从而简化调用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, *, city=<span class="string">'Beijing'</span>, job)</span>:</span></span><br><span class="line">    print(name, age, city, job)</span><br></pre></td></tr></table></figure></p>
<p>由于命名关键字参数city具有默认值，调用时，可不传入city参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; person(&apos;Jack&apos;, 24, job=&apos;Engineer&apos;)</span><br><span class="line">Jack 24 Beijing Engineer</span><br></pre></td></tr></table></figure></p>
<p>使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个<em>作为特殊分隔符。如果缺少</em>，Python解释器将无法识别位置参数和命名关键字参数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, city, job)</span>:</span></span><br><span class="line">    <span class="comment"># 缺少 *，city和job被视为位置参数</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p>
<p>在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5中参数都可以组合使用。<br>但是请注意，参数定义的顺序是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</p>
<h3 id="将函数存储在模块中"><a href="#将函数存储在模块中" class="headerlink" title="将函数存储在模块中"></a>将函数存储在模块中</h3><p>import语句允许在当前运行的程序文件中使用模块中的代码。<br>通过将函数存储在独立的文件中，可隐藏程序代码的细节，将重点放在程序的高层逻辑上。<br>这还能让你在众多不同的程序中重用函数。将函数存储在独立文件中后，可与其他程序员共享<br>这些文件而不是整个程序。<br>要让函数是可导入的，得先创建模块。模块是拓展名为.py的文件，包含要导入到程序中的代码。<br>下面来创建一个包含函数make_pizza()的模块。<br>pizza.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_pizza</span><span class="params">(size,*toppings)</span>:</span></span><br><span class="line">	<span class="string">"""概述要制作的比萨"""</span></span><br><span class="line">	print(<span class="string">"\nMaking a "</span>+str(size)+<span class="string">"-inch pizza with the following toppings:"</span>)</span><br><span class="line">	<span class="keyword">for</span> topping <span class="keyword">in</span> toppings:</span><br><span class="line">		print(<span class="string">"- "</span>+topping)</span><br></pre></td></tr></table></figure></p>
<p>接下来，在pizza.py所在的目录中创建另一个名为making_pizzas.py的文件，<br>这个文件导入刚创建的模块，再调用make_pizza()两次：<br>making_pizzas.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pizza</span><br><span class="line"></span><br><span class="line">pizza.make_pizza(<span class="number">16</span>,<span class="string">'pepperoni'</span>)</span><br><span class="line">pizza.make_pizza(<span class="number">12</span>,<span class="string">'mushrooms'</span>,<span class="string">'green peppers'</span>,<span class="string">'extra cheese'</span>)</span><br></pre></td></tr></table></figure></p>
<p>如果你使用这种import语句导入了名为module_name.py的整个模块。就可使用<br>下面的语法来使用其中任何一个函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module_name.function_name()</span><br></pre></td></tr></table></figure></p>
<p>导入特定的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from module_name import fuction_name</span><br></pre></td></tr></table></figure>
<p>通过用逗号分隔函数名，可根据需要从模块中导入任意数量的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from module_name import function_0,function_1,function_2</span><br></pre></td></tr></table></figure></p>
<p>如果要导入的函数的名称可能与程序中现有的名称冲突，或者函数的名称太长，<br>可指定简短而独一无二的别名–函数的另一个名称，类似于外号。<br>下面给函数make_pizza()指定了别名mp()。这是在import语句中是使用<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">make_pizza <span class="keyword">as</span> mp 实现的，关键字<span class="keyword">as</span>将函数重命名为你提供的别名：</span><br><span class="line"><span class="keyword">from</span> pizza <span class="keyword">import</span> make_pizza <span class="keyword">as</span> mp</span><br><span class="line"></span><br><span class="line">mp(<span class="number">16</span>,<span class="string">'pepperoni'</span>)</span><br><span class="line">mp(<span class="number">12</span>,<span class="string">'mushrooms'</span>,<span class="string">'green peppers'</span>,<span class="string">'extra cheese'</span>)</span><br></pre></td></tr></table></figure></p>
<p>指定别名的通用语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from module_name import function_name as fn</span><br></pre></td></tr></table></figure></p>
<p>使用as给模块指定别名<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pizza <span class="keyword">as</span> p</span><br><span class="line">p.make_pizza(<span class="number">16</span>,<span class="string">'pepperoni'</span>)</span><br><span class="line">p.make_pizza(<span class="number">12</span>,<span class="string">'mushrooms'</span>,<span class="string">'green peppers'</span>,<span class="string">'extra cheese'</span>)</span><br></pre></td></tr></table></figure></p>
<p>给模块指定别名的通用语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import module_name as mn</span><br></pre></td></tr></table></figure></p>
<p>使用星号（*）运算符可让Python导入模块中的所有函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pizza <span class="keyword">import</span> *</span><br><span class="line">make_pizza(<span class="number">16</span>,<span class="string">'pepperoni'</span>)</span><br><span class="line">make_pizza(<span class="number">12</span>,<span class="string">'mushrooms'</span>,<span class="string">'green peppers'</span>,<span class="string">'extra cheese'</span>)</span><br></pre></td></tr></table></figure></p>
<p>注意：使用并非自己编写的大型模块时，最好不要采用这种导入方法。</p>
<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。<br>一个最简单的高阶函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x,y,f)</span></span></span><br><span class="line"><span class="function">	<span class="title">return</span> <span class="title">f</span><span class="params">(x)</span>+<span class="title">f</span><span class="params">(y)</span></span></span><br></pre></td></tr></table></figure></p>
<p>当我们调用add(-5,6,abs)时，参数x,y和f分别接收-5，6和abs,我们可以推导出计算过程为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = -5</span><br><span class="line">y = 6</span><br><span class="line">f = abs</span><br><span class="line">f(x)+f(y)==&gt;abs(-5)+abs(6)==&gt;11</span><br><span class="line">retun 11</span><br></pre></td></tr></table></figure></p>
<p>把函数作为参数传入，这样的函数称为高阶函数。</p>
<h3 id="map-reduce"><a href="#map-reduce" class="headerlink" title="map/reduce"></a>map/reduce</h3><p>Python内建了map()和reduce()函数。其中，map()函数接收两个参数，一个是函数，一个是Iterable,map将传入的函数依次作用到<br>序列的每个元素，并把结果作为新的Iterator返回。<br>比如，有一个函数 $f(x)=x^2$ ,要把这个函数作用于一个list[1,2,3,4,5,6,7,8,9]上，就可以用map()实现如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> x*x</span><br><span class="line">r=map(f,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>])</span><br><span class="line">list(r)</span><br></pre></td></tr></table></figure></p>
<p>结果则为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,4,9,16,25,36,49,64,81]</span><br></pre></td></tr></table></figure></p>
<p>map()传入的第一个参数是f，即函数对象本身。由于结果r是一个Iterator,Iterator是惰性序列，因此通过list()<br>函数让它把整个序列都计算出来并返回一个list。<br>map()函数作为高阶函数，不但可以计算简单的$f(x)=x^2$,还可以计算任意复杂的函数，<br>比如，把这个list所有数字转为字符串：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list(map(str,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]))</span><br><span class="line">[<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'7'</span>,<span class="string">'8'</span>,<span class="string">'9'</span>]</span><br></pre></td></tr></table></figure></p>
<p>只需要一行代码。</p>
<p>reduce把一个函数作用在一个序列[x1,x2,x23,…]上，这个函数必须接收两个参数，reduceba把结果<br>继续和序列的下一个元素做累积计算，其效果就是：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduce(f,[x1,x2,x3,x4])=f(f(f(x1,x2),x3),x4)</span><br></pre></td></tr></table></figure></p>
<p>比方说一个序列[1,3,5,7,9]变换成13579，就可以用reduce实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fu</span><span class="params">(x,y)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> x*<span class="number">10</span> + y</span><br><span class="line">	</span><br><span class="line">reduce(fn,[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>])</span><br></pre></td></tr></table></figure></p>
<p>则结果就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">13579</span><br></pre></td></tr></table></figure></p>
<p>如果考虑到字符串str也是一个序列，对上面的例子稍加改动，配合map(),就可以把str转换为int函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(x,y)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> x*<span class="number">10</span> + y</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">char2num</span><span class="params">(s)</span>:</span></span><br><span class="line">	digits=&#123;<span class="string">'0'</span>:<span class="number">0</span>,<span class="string">'1'</span>:<span class="number">1</span>,<span class="string">'2'</span>:<span class="number">2</span>,<span class="string">'3'</span>:<span class="number">3</span>,<span class="string">'4'</span>:<span class="number">4</span>,<span class="string">'5'</span>:<span class="number">5</span>,<span class="string">'6'</span>:<span class="number">6</span>,<span class="string">'7'</span>:<span class="number">7</span>,<span class="string">'8'</span>:<span class="number">8</span>,<span class="string">'9'</span>:<span class="string">'9'</span>&#125;</span><br><span class="line">	retun digits[s]</span><br><span class="line"></span><br><span class="line">reduce(fn,map(char2num,<span class="string">'13579'</span>))</span><br></pre></td></tr></table></figure></p>
<p>结果则为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">13579</span><br></pre></td></tr></table></figure></p>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>filter()函数用于过滤序列，其接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于<br>每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。<br>例如，在一个list中，删掉偶数，只保留奇数，可以这么写：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is</span> <span class="title">_odd</span><span class="params">(n)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> n%<span class="number">2</span>==<span class="number">1</span></span><br><span class="line"></span><br><span class="line">list(filter(is_odd,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">15</span>]))</span><br><span class="line"><span class="comment">#结果：[1,5,9,15]</span></span><br></pre></td></tr></table></figure></p>
<p>注意到filter()函数返回的是一个Iterator，也就是一个惰性序列，所以要强迫filter()完成<br>计算结果，需要list()函数获得所有结果并返回list。</p>
<h3 id="返回函数-闭包"><a href="#返回函数-闭包" class="headerlink" title="返回函数/闭包"></a>返回函数/闭包</h3><p>闭包(closure)是函数式编程的重要的语法结构。闭包也是一种组织代码的结构，它同样提高了代码的可重复使用性。<br>如果在一个内嵌函数里，对在外部函数内（但不是在全局作用域）的变量进行引用，那么内嵌函数就被认为是闭包(closure)。<br>定义在外部函数内但由内部函数引用或者使用的变量称为自由变量。<br>总结一下,创建一个闭包必须满足以下几点:</p>
<ol>
<li>必须有一个内嵌函数</li>
<li>内嵌函数必须引用外部函数中的变量</li>
<li>外部函数的返回值必须是内嵌函数<br>不返回求和的结果而是返回求和函数，如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lazy_sum</span><span class="params">(*args)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">()</span>:</span></span><br><span class="line">		ax = <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> n <span class="keyword">in</span> args:</span><br><span class="line">			ax=ax+n</span><br><span class="line">		<span class="keyword">return</span> ax</span><br><span class="line">	<span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;f=lazy_sum(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>)</span><br><span class="line">&gt;&gt;&gt;f</span><br><span class="line">&lt;function lazy_sum.&lt;locals&gt;.sum at <span class="number">0x101c6ed90</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>调用函数f时，才真正计算求和的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;f()</span><br><span class="line">25</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，我们在函数lazy_sum中定义了函数sum，并且,内部函数sum可以引用外部函数lazy_sum的参数<br>和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为”闭包”的程序结构。<br>再注意一点，当我们调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;f1=lazy_sum(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>)</span><br><span class="line">&gt;&gt;&gt;f2=lazy_sum(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>)</span><br><span class="line">&gt;&gt;&gt;f1==f2</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<p>f1()和f2()的调用结果互不影响。<br>另一个需要注意的是，返回的函数并没有立刻执行，而是直到调用了f()才执行。如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">()</span>:</span></span><br><span class="line">	fs=[]</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">4</span>):</span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">			<span class="keyword">return</span> i*i</span><br><span class="line">		fs.append(f)</span><br><span class="line">	<span class="keyword">return</span> fs</span><br><span class="line"></span><br><span class="line">f1,f2,f3=cpunt()</span><br></pre></td></tr></table></figure></p>
<p>在上面的例子中，每次循环，都创建了一个新的函数，然后把创建的3个函数都返回了。<br>你可能认为调用f1(),f2(),f3()结果应该是1，4，9，但实际结果是：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;f1()</span><br><span class="line"><span class="number">9</span></span><br><span class="line">&gt;&gt;&gt;f2()</span><br><span class="line"><span class="number">9</span></span><br><span class="line">&gt;&gt;&gt;f3()</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure></p>
<p>全部都是9！，原因就在于返回的函数引用了变量i，但它并非立即执行。等到3个函数都返回时，他们所引用的变量i<br>已经变成了3，因此最终结果为9。<br>注意：返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。<br>如果一定要引用循环变量的话，是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何<br>更改，已绑定到函数参数的值不变：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(j)</span>:</span></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">()</span>:</span></span><br><span class="line">			<span class="keyword">return</span> j*j</span><br><span class="line">		<span class="keyword">return</span> g</span><br><span class="line">	fs=[]</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">4</span>):</span><br><span class="line">		fs.append(f(i))<span class="comment">#f(i)立刻被执行，因此i的当前值被传入f()</span></span><br><span class="line">	<span class="keyword">return</span> fs</span><br></pre></td></tr></table></figure></p>
<p>再看看结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;f1,f2,f3=count()</span><br><span class="line">&gt;&gt;&gt;f1()</span><br><span class="line"><span class="number">1</span></span><br><span class="line">&gt;&gt;&gt;f2()</span><br><span class="line"><span class="number">4</span></span><br><span class="line">&gt;&gt;&gt;f3()</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure></p>
<p>缺点是代码较长，可利用lambda函数缩短代码。</p>
<h3 id="匿名函数-lambda"><a href="#匿名函数-lambda" class="headerlink" title="匿名函数/lambda"></a>匿名函数/lambda</h3><p>当我们再传入函数时，有些时候，不需要显示地定义函数，直接传入匿名函数很方便。<br>以map()函数为例，计算$f(x)=x^2$时，除了定义一个f(x)的函数外，还可以直接传入匿名函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;list(map(<span class="keyword">lambda</span> x :x*x,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]))</span><br><span class="line">[<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">16</span>,<span class="number">25</span>,<span class="number">36</span>,<span class="number">49</span>,<span class="number">64</span>,<span class="number">81</span>]</span><br></pre></td></tr></table></figure></p>
<p>通过对比可以看出，匿名函数lambda x:x*x 实际上就是：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> x*x</span><br></pre></td></tr></table></figure></p>
<p>关键字lambda表示匿名函数，冒号前面的x表示函数参数。<br>匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。<br>用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。次外，匿名函数也是一个函数对象，也可以把匿名函数<br>赋值给一个变量，再利用变量来调用该函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;f=<span class="keyword">lambda</span> x:x*x</span><br><span class="line">&gt;&gt;&gt;f</span><br><span class="line">&lt;function&lt;<span class="keyword">lambda</span>&gt; at <span class="number">0x101c6ef28</span>&gt;</span><br><span class="line">&gt;&gt;&gt;f(<span class="number">5</span>)</span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure></p>
<p>同样，也可以把匿名函数作为返回值返回，比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(x,y)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">lambda</span>: x*x + y*y</span><br></pre></td></tr></table></figure></p>
<h3 id="对yield的总结"><a href="#对yield的总结" class="headerlink" title="对yield的总结"></a>对yield的总结</h3><p>　　（1）：通常的for..in…循环中，in后面是一个数组，这个数组就是一个可迭代对象，类似的还有链表，字符串，文件。他可以是a = [1,2,3]，也可以是a = [x<em>x for x in range(3)]。<br>它的缺点也很明显，就是所有数据都在内存里面，如果有海量的数据，将会非常耗内存。<br>　　（2）生成器是可以迭代的，但是只可以读取它一次。因为用的时候才生成，比如a = (x</em>x for x in range(3))。!!!!注意这里是小括号而不是方括号。<br>　　（3）生成器（generator）能够迭代的关键是他有next()方法，工作原理就是通过重复调用next()方法，直到捕获一个异常。<br>　　（4）带有yield的函数不再是一个普通的函数，而是一个生成器generator，可用于迭代。<br>　　（5）yield是一个类似return 的关键字，迭代一次遇到yield的时候就返回yield后面或者右面的值。而且下一次迭代的时候，从上一次迭代遇到的yield后面的代码开始执行。<br>　　（6）yield就是return返回的一个值，并且记住这个返回的位置。下一次迭代就从这个位置开始。<br>　　（7）带有yield的函数不仅仅是只用于for循环，而且可用于某个函数的参数，只要这个函数的参数也允许迭代参数。<br>　　（8）send()和next()的区别就在于send可传递参数给yield表达式，这时候传递的参数就会作为yield表达式的值，而yield的参数是返回给调用者的值，也就是说send可以强行修改上一个yield表达式值。<br>　　（9）send()和next()都有返回值，他们的返回值是当前迭代遇到的yield的时候，yield后面表达式的值，其实就是当前迭代yield后面的参数。<br>　　（10）第一次调用时候必须先next（）或send（）,否则会报错，send后之所以为None是因为这时候没有上一个yield，所以也可以认为next（）等同于send(None)。</p>
<h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>本质上装饰器（decorator）就是一个返回函数的高阶函数。所以，我们要定义一个能打印日志的decorator，可以定义如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(func)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args,**kw)</span>:</span></span><br><span class="line">		print(<span class="string">'call %s():'</span> % func.__name__)</span><br><span class="line">		<span class="keyword">return</span> func(*args,**kw)</span><br><span class="line">	<span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure></p>
<p>观察上面的log，因为它是一个decorator，所以接受一个函数作为参数，并返回一个函数。我们要借助Python的@语法，<br>把decorator置于函数的定义处：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">()</span>:</span></span><br><span class="line">	print(<span class="string">'2018-6-25'</span>)</span><br></pre></td></tr></table></figure></p>
<p>调用now()函数，不仅会运行now()函数本身，还会在运行now()函数前打印一行日志：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;now()</span><br><span class="line">call now():</span><br><span class="line"><span class="number">2018</span><span class="number">-6</span><span class="number">-25</span></span><br></pre></td></tr></table></figure></p>
<p>把@log放到now()函数的定义处，相当于执行了语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">now=log(now)</span><br></pre></td></tr></table></figure></p>
<p>由于log()是一个decorator,返回一个函数，所以，原来的now()函数任然存在，只是现在同名的now变量指向了新的函数，于是<br>调用now()将执行新函数，即在log()函数中返回的wrapper()函数。<br>wrapper()函数的参数定义是(*args,**kw),因此，wrapper()函数可以接受任意参数的调用。在wrapper()函数内，首先打印日志，<br>再紧接着调用原始函数。<br>如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数。比如，要自定义log的文本：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(text)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">decoraotr</span><span class="params">(func)</span>:</span></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*arag,**kw)</span>:</span></span><br><span class="line">			print(<span class="string">'%s %s():'</span> % (text,func.__name__))</span><br><span class="line">			<span class="keyword">return</span> func(*args,**kw)</span><br><span class="line">		<span class="keyword">return</span> wrapper</span><br><span class="line">	<span class="keyword">return</span> decorator</span><br></pre></td></tr></table></figure></p>
<p>这个3层嵌套的decorator用法如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@log('execute')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">()</span>:</span></span><br><span class="line">	print(<span class="string">'2018-6-25'</span>)</span><br></pre></td></tr></table></figure></p>
<p>执行结果如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;now()</span><br><span class="line">execute now():</span><br><span class="line"><span class="number">2015</span><span class="number">-3</span><span class="number">-25</span></span><br></pre></td></tr></table></figure></p>
<p>和两层嵌套的decorator相比，3层嵌套的效果是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;now=log(&apos;execute&apos;)(now)</span><br></pre></td></tr></table></figure></p>
<p>我们来剖析上面的语句，首先执行log(‘execute’),返回的是decorator函数，再调用返回的函数，<br>参数是now函数，返回值最终是wrapper函数。<br>以上两种decorator的定义都没有问题，但还差最后一步。因为我们讲了函数也是对象，它有<strong>name</strong><br>等属性，但你去看经过decorator装饰之后的函数，它们的<strong>name</strong>已经从原来的’now’变成了’wrapper’:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;now.__name__</span><br><span class="line"><span class="string">'wrapper'</span></span><br></pre></td></tr></table></figure></p>
<p>因为返回的那个wrapper()函数名字就是’wrapper’，所以，需要把原始函数的<strong>name</strong>等属性复制到wrapper()<br>函数中，否则，有些依赖函数签名的代码执行就会出错。不需要编写wrapper.<strong>name</strong>=func.<strong>name</strong>这样的代码，<br>python内置的functools.wraps就是干这个事的，所以，一个完整的decorator的写法如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">	@functools.wraps(func)</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args,**kw)</span>:</span></span><br><span class="line">		print(<span class="string">'call %s():'</span> % func.__name__)</span><br><span class="line">		<span class="keyword">return</span> func(*args,**kw)</span><br><span class="line">	<span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure></p>
<p>或者针对带参数的decorator：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(text)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">		@functools.wrap(func)</span></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args,**kw)</span>:</span></span><br><span class="line">			print(<span class="string">'%s %s():'</span>% (text,func.__name__))</span><br><span class="line">			<span class="keyword">return</span> func(*args,**kw)</span><br><span class="line">		<span class="keyword">return</span> wrapper</span><br><span class="line">	<span class="keyword">return</span> decorator</span><br><span class="line"><span class="keyword">import</span> functools是导入functools模块。模块的概念稍后讲解。现在，只需记住再定义wrapper()的前面加上</span><br><span class="line"><span class="meta">@functools.wraps(func)即可。</span></span><br></pre></td></tr></table></figure></p>
<h3 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h3><p>functools.partial可帮助我们创建一个偏函数。如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">import</span> functools</span><br><span class="line">&gt;&gt;&gt;int2=functools.partial(int,base=<span class="number">2</span>)</span><br><span class="line">&gt;&gt;&gt;int2(<span class="string">'1000000'</span>)</span><br><span class="line"><span class="number">64</span></span><br><span class="line">&gt;&gt;&gt;int2(<span class="string">'1010101'</span>)</span><br><span class="line"><span class="number">85</span></span><br></pre></td></tr></table></figure></p>
<p>简单总结functools.partial的作用就是，把一个函数的某些参数给固定住（设置默认值）,返回一个新的函数，<br>调用这个新函数会更简单。注意到上面的新的int2函数，仅仅是把base参数重新设定默认值为2，但也可以再函数调用时传入其他值：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;int2(<span class="string">'1000000'</span>,base=<span class="number">10</span>)</span><br><span class="line"><span class="number">1000000</span></span><br></pre></td></tr></table></figure></p>
<p>最后，创建偏函数时，实际上可以接收函数对象、args和**kw着3个参数，当传入：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int2=functools.partial(int,base=<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<p>实际上固定了int()函数的关键字参数base，也就是：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int2(<span class="string">'10010'</span>)</span><br></pre></td></tr></table></figure></p>
<p>相当于：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kw=&#123;<span class="string">'base'</span>:<span class="number">2</span>&#125;</span><br><span class="line">int(<span class="string">'10010'</span>,**kw)</span><br></pre></td></tr></table></figure></p>
<p>当传入：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max2=functools.partial(max,<span class="number">10</span>)</span><br></pre></td></tr></table></figure></p>
<p>实际上会把10作为*args的一部分自动加到左边，也就是：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max2(<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br></pre></td></tr></table></figure></p>
<p>相当于：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">args=(<span class="number">10</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line">max(*args)</span><br></pre></td></tr></table></figure></p>
<p>结果为10。</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="使用类和实例"><a href="#使用类和实例" class="headerlink" title="使用类和实例"></a>使用类和实例</h3><p>dog.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="string">"""一次模拟小狗的简单尝试"""</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span></span><br><span class="line">		<span class="string">"""初始化属性name和age"""</span></span><br><span class="line">		self.name = name</span><br><span class="line">		self.age = age</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">sit</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="string">"""模拟小狗被命令时蹲下"""</span></span><br><span class="line">		print(self.name.title()+<span class="string">" is now sitting."</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">roll_over</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="string">"""模拟小狗命令时打滚"""</span></span><br><span class="line">		print(self.name.title()+<span class="string">" rolled over!"</span>)</span><br></pre></td></tr></table></figure></p>
<p>根据约定，在python中，首字母大写的名称指的是类。<br>类中的函数称为方法。每当你根据Dog类创建新实例时，Python都会自动运行<strong>init</strong>()这个方法。<br>Python调用这个<strong>init</strong>()方法来创建Dog实例时，将自动传入实参self。，每个与类相关联<br>的方法调用都自动传递参数self，它是指向实例本身的引用，让实例能过访问类中的属性和方法。<br>可将类视为有关如何创建实例的说明。Dog类是一系列说明，让Python知道如何创建表示特定小狗的实例。</p>
<p>类中的每个属性都必须有初始值，哪怕这个值是0或空字符串。在有些情况下，如设置默认值时，在方法<br><strong>init</strong>()内指定这种初始值是可行的。如果你多某个属性这样做了，就无需包含为它提供初始值的形参。</p>
<h3 id="修改属性的值"><a href="#修改属性的值" class="headerlink" title="修改属性的值"></a>修改属性的值</h3><p>要修改属性的值，最简单的方式是通过实例直接访问它<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,make,model,year)</span>:</span></span><br><span class="line">		<span class="string">"""初始化描述汽车的属性"""</span></span><br><span class="line">		self.make = make</span><br><span class="line">		self.model = model</span><br><span class="line">		self.year = year</span><br><span class="line">		self.odometer_reading = <span class="number">0</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get_descripetive_name</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="string">"""返回整洁的描述性信息"""</span></span><br><span class="line">		long_name = str(self.year)+<span class="string">' '</span>+self.make + <span class="string">' '</span>+self.model</span><br><span class="line">		<span class="keyword">return</span> long_name.title()</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">read_odometer</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="string">"""打印一条指出汽车里程的消息"""</span></span><br><span class="line">		print(<span class="string">"this car has "</span>+str(self.odometer_reading)+<span class="string">"miles on it."</span>)</span><br><span class="line">		</span><br><span class="line">	my_new_car=Car(<span class="string">'audi'</span>,<span class="string">'a4'</span>,<span class="number">2016</span>)</span><br><span class="line">	print(my_new_car.get_descriptive_name())</span><br><span class="line">	my_new_car.odometer_reading = <span class="number">23</span></span><br><span class="line">	my_new_car.read_odometer()</span><br></pre></td></tr></table></figure></p>
<p>结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2016 Audi A4</span><br><span class="line">This car has 23 miles on it.</span><br></pre></td></tr></table></figure></p>
<p>通过方法修改属性的值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span><span class="params">()</span>:</span></span><br><span class="line">	--snip--</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">update_odometer</span><span class="params">(self,mileage)</span>:</span></span><br><span class="line">		<span class="string">"""将里程表读数设置为指定的值"""</span></span><br><span class="line">		self.odometer_reading = mileage</span><br><span class="line"></span><br><span class="line">	my_new_car=Car(<span class="string">'audi'</span>,<span class="string">'a4'</span>,<span class="number">2016</span>)</span><br><span class="line">	print(my_new_car.get_descriptive_name())</span><br><span class="line">	my_new_car.update_odometer(<span class="number">23</span>)</span><br><span class="line">	my_new_car.read_odometer()</span><br></pre></td></tr></table></figure></p>
<p>如果要让内部属性不被外部访问，可以在属性的名称前加上两个下划线<strong>，在python中，实例的变量名如果以</strong>开头，<br>就变成了一个私有变量(private)，只有内部可以访问，外部不能访问。比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,score)</span>:</span></span><br><span class="line">		self.__name=name</span><br><span class="line">		self.__score=score</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">print_socre</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">'%s:%s'</span> %(self.__name,self.__score))</span><br></pre></td></tr></table></figure></p>
<p>此时，就无法从外部访问实例变量.<strong>name和实例变量.</strong>score了。<br>如果又要允许外部代码修改score怎么办？可以再给Student类增加set_score方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">set_score</span><span class="params">(self,score)</span>:</span></span><br><span class="line">		self._score=score</span><br></pre></td></tr></table></figure></p>
<p>注意：在python中变量名类似<strong>xxx</strong>的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量。<br>双下划线开头的实例变量是不是一定不能从外部访问呢？其实不能直接访问<strong>name是因为python解释器对外把</strong>name变量改成<br>了_Student_name，所以，仍然可以通过_Student_name来访问<strong>name变量。<br>但是强烈建议你不要这么干，因为不同版本的python解释器可能会把</strong>name改成不同的变量名。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>一个类继承另一个类时，它将自动获得另一个类的所有属性和方法。<br>原有的类称为父类，而新类称为子类。子类继承了其父类的所有属性和方法，<br>同时还可以定义自己的属性和方法。<br>创建子类的实例时，Python首先要完成的任务是给父类的所有属性赋值。为此，<br>子类的方法<strong>init</strong>()需要父类施以援手。<br>下面来模拟电动汽车，在前面创建的Car类的基础上创建新类ElectricCar，它具备Car的所有功能：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElectricCar</span><span class="params">(Car)</span>:</span></span><br><span class="line">	<span class="string">"""电动汽车的独特之处"""</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,make,model,year)</span>:</span></span><br><span class="line">		<span class="string">"""</span></span><br><span class="line"><span class="string">		电动汽车的独特之处</span></span><br><span class="line"><span class="string">		初始化父类的属性，再初始化电动汽车特有的属性</span></span><br><span class="line"><span class="string">		"""</span></span><br><span class="line">		super().__init__(make,model,year)</span><br><span class="line">		self.battery_size = <span class="number">70</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">describe_battery</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="string">"""打印一条描述电瓶容量的消息"""</span>	</span><br><span class="line">		print(<span class="string">"This car has a "</span>+ str(self.battery_size)+<span class="string">"-kwh battery."</span>)</span><br><span class="line">		</span><br><span class="line">my_tesla = ElectricCar(<span class="string">'tesla'</span>,<span class="string">'model s'</span>,<span class="string">'2016'</span>)</span><br><span class="line">print(my_tesla.get_descriptive_name())</span><br><span class="line">my_tesla.describe_battery()</span><br></pre></td></tr></table></figure></p>
<p>创建子类时，父类必须包含在当前文件中，且位于子类面前。<br>定义子类时必须在括号内定义父类的名称。方法<strong>init</strong>()接受创建Car实例所需的信息。<br>super()帮助Python将父类和子类关联起来。这行代码让Python调用ElectricCar的父类的方法<strong>init</strong>(),<br>让ElectricCar实例包含父类的所有属性。父类也称为超类，名称super因此而得名。<br>对于父类的方法，只要它不符合子类模拟的实物的行为，都可对其进行重写。<br>为此，可在子类中定义一个这样的方法，即它与要重写的父类的方法同名。</p>
<p>在不断给ElectricCar类添加细节时，可能发现其中包含很多专门针对汽车电瓶的属性和方法。<br>在这种情况下，我们可以将这些属性和方法提取出来，放到另一个名为Battery的类中，<br>并将一个Battery实例用作ElectricCar类的一个属性：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span><span class="params">()</span>:</span></span><br><span class="line">	--snip--</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Battery</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="string">"""一次模拟电动汽车电瓶的简单尝试"""</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,battery_size =<span class="number">70</span>)</span>:</span></span><br><span class="line">		<span class="string">"""初始化电瓶的属性"""</span></span><br><span class="line">		self.battery_size = battery_size</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">describe_battery</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="string">"""打印一条描述电瓶容量的消息"""</span></span><br><span class="line">		print(<span class="string">"This car has a "</span>+str(self.battery_size)+<span class="string">"-kwh battery."</span>)</span><br><span class="line">		</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElectricCar</span><span class="params">(Car)</span>:</span></span><br><span class="line">	<span class="string">"""电动汽车的独特之处"""</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,make,model,year)</span>:</span></span><br><span class="line">		<span class="string">"""</span></span><br><span class="line"><span class="string">		初始化父类的属性，再初始化电动汽车特有的属性</span></span><br><span class="line"><span class="string">		"""</span></span><br><span class="line">		super().__init__(make,model,year)</span><br><span class="line">		self.battery = Battery()</span><br><span class="line">		</span><br><span class="line">my_tesla=ElectricCar(<span class="string">'tesla'</span>,<span class="string">'model s'</span>,<span class="number">2006</span>)</span><br><span class="line">print(my_tesla.get_descriptive_name())</span><br><span class="line">my_tesla.battery.describe_battery()</span><br></pre></td></tr></table></figure></p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>对于静态语言（例如java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。<br>对于python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Timer</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">'Start...'</span>)</span><br></pre></td></tr></table></figure></p>
<p>这就是动态语言的”鸭子类型”，它并不要求严格的继承体系，一个对象只要”看起来像鸭子，走起路来像鸭子”，那它就可以被看作是鸭子。<br>Python的”file-like object”就是一种鸭子类型。对真正的文件对象，它有一个read()方法，返回其内容。但是，许多对象，只要有read()方法，<br>都被视为”file-like object”。许多函数接收的参数就是”file-like object”,你不一定要传入真正的文件对象，完全可以传入任何实现了read()方法的对象。</p>
<h3 id="导入类"><a href="#导入类" class="headerlink" title="导入类"></a>导入类</h3><p>Python允许你将类存储在模块中，然后在主程序中导入所需的模块。<br>可根据需要在程序文件中导入任意数量的类。如果我们要在同一个程序中创建普通汽车和电动汽车，<br>就需要将Car和ElectricCar类都导入：<br>my_cars.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> car <span class="keyword">import</span> Car,ElectriCar</span><br><span class="line"></span><br><span class="line">my_beetle = Car(<span class="string">'volkswagen'</span>,<span class="string">'beetle'</span>,<span class="number">2016</span>)</span><br><span class="line">print(my_beetle.get_descriptive_name())</span><br><span class="line">my_tesla = ElectricCar(<span class="string">'tesla'</span>, <span class="string">'roadster'</span>, <span class="number">2016</span>)</span><br><span class="line">print(my_tesla.get_descriptive_name())</span><br></pre></td></tr></table></figure></p>
<p>还可以导入整个模块，再使用句点表示访问需要的类。比如：import car<br>要导入模块中的每个类，可使用下面的语法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> module_name <span class="keyword">import</span> *  <span class="comment">#不建议使用</span></span><br></pre></td></tr></table></figure></p>
<h2 id="面向对象高级编程"><a href="#面向对象高级编程" class="headerlink" title="面向对象高级编程"></a>面向对象高级编程</h2><h3 id="slots"><a href="#slots" class="headerlink" title="slots"></a><strong>slots</strong></h3><p>正常情况下，当我们定义了一个class，创建了一个class的实例后，我们可以给该实例绑定任何属性和方法，这就是动态语言的灵活性。先定义class：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p>
<p>然后，尝试给实例绑定一个属性：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.name = <span class="string">'Michael'</span> <span class="comment"># 动态给实例绑定一个属性</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(s.name)</span><br><span class="line">Michael</span><br></pre></td></tr></table></figure></p>
<p>还可以尝试给实例绑定一个方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">set_age</span><span class="params">(self, age)</span>:</span> <span class="comment"># 定义一个函数作为实例方法</span></span><br><span class="line"><span class="meta">... </span>    self.age = age</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> types <span class="keyword">import</span> MethodType</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.set_age = MethodType(set_age, s) <span class="comment"># 给实例绑定一个方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.set_age(<span class="number">25</span>) <span class="comment"># 调用实例方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.age <span class="comment"># 测试结果</span></span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure></p>
<p>但是，给一个实例绑定的方法，对另一个实例是不起作用的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = Student() <span class="comment"># 创建新的实例</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2.set_age(<span class="number">25</span>) <span class="comment"># 尝试调用方法</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">'Student'</span> object has no attribute <span class="string">'set_age'</span></span><br></pre></td></tr></table></figure></p>
<p>为了给所有实例都绑定方法，可以给class绑定方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">set_score</span><span class="params">(self, score)</span>:</span></span><br><span class="line"><span class="meta">... </span>    self.score = score</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Student.set_score = set_score</span><br></pre></td></tr></table></figure></p>
<p>给class绑定方法后，所有实例均可调用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.set_score(<span class="number">100</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2.set_score(<span class="number">99</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2.score</span><br><span class="line"><span class="number">99</span></span><br></pre></td></tr></table></figure></p>
<p>通常情况下，上面的set_score方法可以直接定义在class中，但动态绑定允许我们在程序运行的过程中动态给class加上功能，这在静态语言中很难实现。<br><strong>使用<strong>slots</strong></strong><br>但是，如果我们想要限制实例的属性怎么办？比如，只允许对Student实例添加name和age属性。<br>为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的<strong>slots</strong>变量，来限制该class实例能添加的属性：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    __slots__ = (<span class="string">'name'</span>, <span class="string">'age'</span>) <span class="comment"># 用tuple定义允许绑定的属性名称</span></span><br></pre></td></tr></table></figure></p>
<p>然后，我们试试：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student() <span class="comment"># 创建新的实例</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.name = <span class="string">'Michael'</span> <span class="comment"># 绑定属性'name'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.age = <span class="number">25</span> <span class="comment"># 绑定属性'age'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score = <span class="number">99</span> <span class="comment"># 绑定属性'score'</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">'Student'</span> object has no attribute <span class="string">'score'</span></span><br></pre></td></tr></table></figure></p>
<p>由于’score’没有被放到<strong>slots</strong>中，所以不能绑定score属性，试图绑定score将得到AttributeError的错误。<br>使用<strong>slots</strong>要注意，<strong>slots</strong>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">GraduateStudent</span><span class="params">(Student)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = GraduateStudent()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.score = <span class="number">9999</span></span><br><span class="line">除非在子类中也定义__slots__，这样，子类实例允许定义的属性就是自身的__slots__加上父类的__slots__。</span><br></pre></td></tr></table></figure></p>
<h3 id="使用-property"><a href="#使用-property" class="headerlink" title="使用@property"></a>使用@property</h3><p>Python内置的@property装饰器就是负责把一个方法变成属性调用的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def score(self):</span><br><span class="line">        return self._score</span><br><span class="line"></span><br><span class="line">    @score.setter</span><br><span class="line">    def score(self, value):</span><br><span class="line">        if not isinstance(value, int):</span><br><span class="line">            raise ValueError(&apos;score must be an integer!&apos;)</span><br><span class="line">        if value &lt; 0 or value &gt; 100:</span><br><span class="line">            raise ValueError(&apos;score must between 0 ~ 100!&apos;)</span><br><span class="line">        self._score = value</span><br></pre></td></tr></table></figure></p>
<p>把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值.<br>从上可以看出，不定义setter方法就是一个只读属性.<br>等效效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = Student()</span><br><span class="line">&gt;&gt;&gt; s.score = 60 # OK，实际转化为s.set_score(60)</span><br><span class="line">&gt;&gt;&gt; s.score # OK，实际转化为s.get_score()</span><br><span class="line">60</span><br><span class="line">&gt;&gt;&gt; s.score = 9999</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: score must between 0 ~ 100!</span><br></pre></td></tr></table></figure></p>
<h3 id="定制类"><a href="#定制类" class="headerlink" title="定制类"></a>定制类</h3><p>Python的class中还有许多这样有特殊用途的函数，可以帮助我们定制类。</p>
<p><strong>str</strong></p>
<p>我们先定义一个Student类，打印一个实例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.name = name</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(Student(<span class="string">'Michael'</span>))</span><br><span class="line">&lt;__main__.Student object at <span class="number">0x109afb190</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>打印出一堆&lt;<strong>main</strong>.Student object at 0x109afb190&gt;，不好看。<br>怎么才能打印得好看呢？只需要定义好<strong>str</strong>()方法，返回一个好看的字符串就可以了：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.name = name</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">'Student object (name: %s)'</span> % self.name</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(Student(<span class="string">'Michael'</span>))</span><br><span class="line">Student object (name: Michael)</span><br></pre></td></tr></table></figure></p>
<p>这样打印出来的实例，不但好看，而且容易看出实例内部重要的数据。<br>但是细心的朋友会发现直接敲变量不用print，打印出来的实例还是不好看：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student(<span class="string">'Michael'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&lt;__main__.Student object at <span class="number">0x109afb310</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>这是因为直接显示变量调用的不是<strong>str</strong>()，而是<strong>repr</strong>()，两者的区别是<strong>str</strong>()返回用户看到的字符串，而<strong>repr</strong>()返回程序开发者看到的字符串，也就是说，<strong>repr</strong>()是为调试服务的。<br>解决办法是再定义一个<strong>repr</strong>()。但是通常<strong>str</strong>()和<strong>repr</strong>()代码都是一样的，所以，有个偷懒的写法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Student object (name=%s)'</span> % self.name</span><br><span class="line">    __repr__ = __str__</span><br><span class="line">__iter__</span><br></pre></td></tr></table></figure></p>
<p>如果一个类想被用于for … in循环，类似list或tuple那样，就必须实现一个<strong>iter</strong>()方法，<br>该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的<strong>next</strong>()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。<br>我们以斐波那契数列为例，写一个Fib类，可以作用于for循环：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a, self.b = <span class="number">0</span>, <span class="number">1</span> <span class="comment"># 初始化两个计数器a，b</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self <span class="comment"># 实例本身就是迭代对象，故返回自己</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a, self.b = self.b, self.a + self.b <span class="comment"># 计算下一个值</span></span><br><span class="line">        <span class="keyword">if</span> self.a &gt; <span class="number">100000</span>: <span class="comment"># 退出循环的条件</span></span><br><span class="line">            <span class="keyword">raise</span> StopIteration()</span><br><span class="line">        <span class="keyword">return</span> self.a <span class="comment"># 返回下一个值</span></span><br></pre></td></tr></table></figure></p>
<p>现在，试试把Fib实例作用于for循环：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> Fib():</span><br><span class="line"><span class="meta">... </span>    print(n)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">...</span><br><span class="line"><span class="number">46368</span></span><br><span class="line"><span class="number">75025</span></span><br></pre></td></tr></table></figure></p>
<p><strong>getitem</strong><br>Fib实例虽然能作用于for循环，看起来和list有点像，但是，把它当成list来使用还是不行，比如，取第5个元素：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fib()[<span class="number">5</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'Fib'</span> object does <span class="keyword">not</span> support indexing</span><br></pre></td></tr></table></figure></p>
<p>要表现得像list那样按照下标取出元素，需要实现<strong>getitem</strong>()方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        a, b = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(n):</span><br><span class="line">            a, b = b, a + b</span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure></p>
<p>现在，就可以按下标访问数列的任意一项了：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = Fib()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">0</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">1</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">2</span>]</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">3</span>]</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">10</span>]</span><br><span class="line"><span class="number">89</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">100</span>]</span><br><span class="line"><span class="number">573147844013817084101</span></span><br></pre></td></tr></table></figure></p>
<p>但是list有个神奇的切片方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(range(<span class="number">100</span>))[<span class="number">5</span>:<span class="number">10</span>]</span><br><span class="line">[<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure></p>
<p>对于Fib却报错。原因是<strong>getitem</strong>()传入的参数可能是一个int，也可能是一个切片对象slice，所以要做判断：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(n, int): <span class="comment"># n是索引</span></span><br><span class="line">            a, b = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> range(n):</span><br><span class="line">                a, b = b, a + b</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">        <span class="keyword">if</span> isinstance(n, slice): <span class="comment"># n是切片</span></span><br><span class="line">            start = n.start</span><br><span class="line">            stop = n.stop</span><br><span class="line">            <span class="keyword">if</span> start <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">                start = <span class="number">0</span></span><br><span class="line">            a, b = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">            L = []</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> range(stop):</span><br><span class="line">                <span class="keyword">if</span> x &gt;= start:</span><br><span class="line">                    L.append(a)</span><br><span class="line">                a, b = b, a + b</span><br><span class="line">            <span class="keyword">return</span> L</span><br></pre></td></tr></table></figure></p>
<p>现在试试Fib的切片：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = Fib()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">0</span>:<span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f[:<span class="number">10</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span>]</span><br></pre></td></tr></table></figure></p>
<p>但是没有对step参数作处理：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f[:<span class="number">10</span>:<span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span>, <span class="number">89</span>]</span><br></pre></td></tr></table></figure></p>
<p>也没有对负数作处理，所以，要正确实现一个<strong>getitem</strong>()还是有很多工作要做的。<br>此外，如果把对象看成dict，<strong>getitem</strong>()的参数也可能是一个可以作key的object，例如str。<br>与之对应的是<strong>setitem</strong>()方法，把对象视作list或dict来对集合赋值。最后，还有一个<strong>delitem</strong>()方法，用于删除某个元素。<br>总之，通过上面的方法，我们自己定义的类表现得和Python自带的list、tuple、dict没什么区别，这完全归功于动态语言的“鸭子类型”，不需要强制继承某个接口。</p>
<p><strong>getattr</strong></p>
<p>正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。比如定义Student类：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = <span class="string">'Michael'</span></span><br></pre></td></tr></table></figure></p>
<p>调用name属性，没问题，但是，调用不存在的score属性，就有问题了：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(s.name)</span><br><span class="line">Michael</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(s.score)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">AttributeError: <span class="string">'Student'</span> object has no attribute <span class="string">'score'</span></span><br></pre></td></tr></table></figure></p>
<p>错误信息很清楚地告诉我们，没有找到score这个attribute。<br>要避免这个错误，除了可以加上一个score属性外，Python还有另一个机制，那就是写一个<strong>getattr</strong>()方法，动态返回一个属性。修改如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = <span class="string">'Michael'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, attr)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> attr==<span class="string">'score'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">99</span></span><br></pre></td></tr></table></figure></p>
<p>当调用不存在的属性时，比如score，Python解释器会试图调用<strong>getattr</strong>(self, ‘score’)来尝试获得属性，这样，我们就有机会返回score的值：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.name</span><br><span class="line"><span class="string">'Michael'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score</span><br><span class="line"><span class="number">99</span></span><br></pre></td></tr></table></figure></p>
<p>返回函数也是完全可以的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, attr)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> attr==<span class="string">'age'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">lambda</span>: <span class="number">25</span></span><br></pre></td></tr></table></figure></p>
<p>只是调用方式要变为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.age()</span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure></p>
<p>注意，只有在没有找到属性的情况下，才调用<strong>getattr</strong>，已有的属性，比如name，不会在<strong>getattr</strong>中查找。<br>此外，注意到任意调用如s.abc都会返回None，这是因为我们定义的<strong>getattr</strong>默认返回就是None。要让class只响应特定的几个属性，我们就要按照约定，抛出AttributeError的错误：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, attr)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> attr==<span class="string">'age'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">lambda</span>: <span class="number">25</span></span><br><span class="line">        <span class="keyword">raise</span> AttributeError(<span class="string">'\'Student\' object has no attribute \'%s\''</span> % attr)</span><br></pre></td></tr></table></figure></p>
<p>这实际上可以把一个类的所有属性和方法调用全部动态化处理了，不需要任何特殊手段。<br>这种完全动态调用的特性有什么实际作用呢？作用就是，可以针对完全动态的情况作调用。<br>举个例子：<br>现在很多网站都搞REST API，比如新浪微博、豆瓣啥的，调用API的URL类似：<br><a href="http://api.server/user/friends" target="_blank" rel="noopener">http://api.server/user/friends</a><br><a href="http://api.server/user/timeline/list" target="_blank" rel="noopener">http://api.server/user/timeline/list</a><br>如果要写SDK，给每个URL对应的API都写一个方法，那得累死，而且，API一旦改动，SDK也要改。<br>利用完全动态的<strong>getattr</strong>，我们可以写出一个链式调用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chain</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, path=<span class="string">''</span>)</span>:</span></span><br><span class="line">        self._path = path</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, path)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Chain(<span class="string">'%s/%s'</span> % (self._path, path))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._path</span><br><span class="line"></span><br><span class="line">    __repr__ = __str__</span><br></pre></td></tr></table></figure></p>
<p>试试：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Chain().status.user.timeline.list</span><br><span class="line"><span class="string">'/status/user/timeline/list'</span></span><br></pre></td></tr></table></figure></p>
<p>这样，无论API怎么变，SDK都可以根据URL实现完全动态的调用，而且，不随API的增加而改变！<br>还有些REST API会把参数放到URL中，比如GitHub的API：<br>GET /users/:user/repos<br>调用时，需要把:user替换为实际用户名。如果我们能写出这样的链式调用：<br>Chain().users(‘michael’).repos<br>就可以非常方便地调用API了。有兴趣的童鞋可以试试写出来。</p>
<p><strong>call</strong></p>
<p>一个对象实例可以有自己的属性和方法，当我们调用实例方法时，我们用instance.method()来调用。能不能直接在实例本身上调用呢？在Python中，答案是肯定的。<br>任何类，只需要定义一个<strong>call</strong>()方法，就可以直接对实例进行调用。请看示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'My name is %s.'</span> % self.name)</span><br></pre></td></tr></table></figure></p>
<p>调用方式如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student(<span class="string">'Michael'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s() <span class="comment"># self参数不要传入</span></span><br><span class="line">My name <span class="keyword">is</span> Michael.</span><br></pre></td></tr></table></figure></p>
<p><strong>call</strong>()还可以定义参数。对实例进行直接调用就好比对一个函数进行调用一样，所以你完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没啥根本的区别。<br>如果你把对象看成函数，那么函数本身其实也可以在运行期动态创建出来，因为类的实例都是运行期创建出来的，这么一来，我们就模糊了对象和函数的界限。<br>那么，怎么判断一个变量是对象还是函数呢？其实，更多的时候，我们需要判断一个对象是否能被调用，能被调用的对象就是一个Callable对象，比如函数和我们上面定义的带有<strong>call</strong>()的类实例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>callable(Student())</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>callable(max)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>callable([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>callable(<span class="keyword">None</span>)</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>callable(<span class="string">'str'</span>)</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<p>通过callable()函数，我们就可以判断一个对象是否是“可调用”对象。</p>
<p>补充：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># =============================================</span></span><br><span class="line"><span class="comment"># 完全动态调用特性：</span></span><br><span class="line"><span class="comment"># 把一个类的所有属性和方法调用全部动态化处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># __call__(): 用于实例自身的调用，达到()调用的效果</span></span><br><span class="line"><span class="comment"># 即可以把此类的对象当作函数来使用，相当于重载了括号运算符</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># __getattr__(): 当调用不存在的属性时调用此方法来尝试获得属性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chain</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, path=<span class="string">''</span>)</span>:</span>    <span class="comment"># 默认路径参数path为空</span></span><br><span class="line">        self._path = path</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, path)</span>:</span></span><br><span class="line">        print(<span class="string">'call __getattr__(%s)'</span> % path)</span><br><span class="line">        <span class="keyword">return</span> Chain(<span class="string">'%s/%s'</span> % (self._path, path))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._path</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, param)</span>:</span></span><br><span class="line">        print(<span class="string">'cal __call__(%s)'</span> % param)</span><br><span class="line">        <span class="keyword">return</span> Chain(<span class="string">'%s/%s'</span> % (self._path, param))</span><br><span class="line"></span><br><span class="line">    __repr__ = __str__</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># /status/user/timeline/list</span></span><br><span class="line"><span class="comment"># Chain().status.user.timeline.list调用分析</span></span><br><span class="line"><span class="comment"># 首先执行Chain()返回一个实例对象C1(path = '')，</span></span><br><span class="line"><span class="comment"># 通过实例对象C1来获取status属性，因为C1中不存在status属性，所以就会调用</span></span><br><span class="line"><span class="comment"># __getattr__()来尝试获取status属性，接着通过__getattr__()方法返回</span></span><br><span class="line"><span class="comment"># 带参数status的实例对象C2(path = '/status')，然后通过实例对象C2来获取user属性，</span></span><br><span class="line"><span class="comment"># C2中不存在user属性，接着调用__getattr__()方法返回带参数user</span></span><br><span class="line"><span class="comment"># 的实例对象C3(path = '/status/user')，然后通过实例对象C3来获取timeline属性，</span></span><br><span class="line"><span class="comment"># 因C3不存在timeline属性，故调用__getattr__()方法返回带参数timeline</span></span><br><span class="line"><span class="comment"># 的实例对象C4(path = '/status/user/timeline')，通过实例对象C4来获取list属性，</span></span><br><span class="line"><span class="comment"># 又因C4中不存在list属性，调用__getattr__()方法返回带参数list</span></span><br><span class="line"><span class="comment"># 的实例对象C5(path = '/status/user/timeline/list')，</span></span><br><span class="line"><span class="comment"># 最后通过调用__str__()方法来打印实例对象C5，即返回/status/user/timeline/list</span></span><br><span class="line"><span class="comment"># 具体参考见下面的测试结果</span></span><br><span class="line">print(Chain().status.user.timeline.list)</span><br><span class="line">print(<span class="string">'--------------------------------------'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># GET /users/:user/repos</span></span><br><span class="line"><span class="comment"># :user替换为实际用户名</span></span><br><span class="line"><span class="comment"># /users/Lollipop/repos</span></span><br><span class="line"><span class="comment"># Chain().users('Lollipop').repos 调用分析</span></span><br><span class="line"><span class="comment"># 首先执行Chain()返回一个实例对象Q1(path = '')，</span></span><br><span class="line"><span class="comment"># 通过实例对象Q1来获取users属性，因为Q1中不存在users属性，</span></span><br><span class="line"><span class="comment"># 所以就会调用__getattr__()方法尝试获取users属性，接着通过</span></span><br><span class="line"><span class="comment"># __getattr__()方法返回带参数users的实例对象Q2(path = '/users')，</span></span><br><span class="line"><span class="comment"># 然后因为通过()直接调用实例对象Q2，并带参数'Lollipop'，故会调用</span></span><br><span class="line"><span class="comment"># __call__()方法，返回了带参数Lollipop的实例对象Q3(path = '/users/Lollipop')，</span></span><br><span class="line"><span class="comment"># 接着通过实例对象Q3来获取repos属性，又因Q3中不存在repos属性，即会调用</span></span><br><span class="line"><span class="comment"># __getattr__()方法返回带参数repos的实例对象Q4(path = '/users/Lollipop/repos')</span></span><br><span class="line"><span class="comment"># 最后通过调用__str__()方法来打印实例对象Q4，即返回/users/Lollipop/repos</span></span><br><span class="line"><span class="comment"># 具体参考见下面的测试结果</span></span><br><span class="line">print(Chain().users(<span class="string">'Lollipop'</span>).repos)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string"># log analysis</span></span><br><span class="line"><span class="string">call __getattr__(status)</span></span><br><span class="line"><span class="string">call __getattr__(user)</span></span><br><span class="line"><span class="string">call __getattr__(timeline)</span></span><br><span class="line"><span class="string">call __getattr__(list)</span></span><br><span class="line"><span class="string">/status/user/timeline/list</span></span><br><span class="line"><span class="string">--------------------------------------</span></span><br><span class="line"><span class="string">call __getattr__(users)</span></span><br><span class="line"><span class="string">cal __call__(Lollipop)</span></span><br><span class="line"><span class="string">call __getattr__(repos)</span></span><br><span class="line"><span class="string">/users/ollipop/repos</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure></p>
<p>疑惑<br>１．为什么实例对象会获取status属性？<br>２. 明明没有循环语句，为什么能够持续地返回？<br>解释：<br>１．因为’.’这个符号，代表的就是“实例.属性”这一绑定关系，在前几章老师已经教过了。<br>２．Chain().status.user.timeline.list这个式子，代表的就是chain（）的status属性的user属性的timelin属性的list属性，这种俄罗斯套娃的即视感有没有让大家想起函数式编程的reduce（）方法？就是这样，通过层层剥离，就能够产生持续的返回效果。<br>我对chain()案例的理解<br>这个案例属于一种对getattr的妙用，通过getattr的性质，把“／”这一符号替换成“.”，仅此而已，大家千万不像我一样，试图理解一些更加深刻的含义，因此陷入思维误区。</p>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>举个例子，一个abc.py的文件就是一个名字叫abc的模块，一个xyz.py的文件就是一个名字叫xyz的模块。<br>现在，假设我们的abc和xyz这两个模块名字与其他模块冲突了，我们可通过包来组织模块，避免冲突。方法时选择一个顶层包名，<br>比如mycompany，按照如下目录存放：<br>mycompany<br>├─ <strong>init</strong>.py<br>├─ abc.py<br>└─ xyz.py<br>引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。现在，abc.py模块的名字就变成<br>了mycompany.abc，类似的，xyz.py的模块名变成了mycompany.xyz。<br>请注意，每一个包目录下面都会有一个<strong>init</strong>.py的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。<br><strong>init</strong>.py可以是空文件，也可以有Python代码，因为<strong>init</strong>.py本身就是一个模块，而它的模块名就是mycompany。<br>类似的，可以有多级目录，组成多级层次的包结构。比如如下的目录结构：<br>mycompany<br> ├─ web<br> │  ├─ <strong>init</strong>.py<br> │  ├─ utils.py<br> │  └─ <a href="http://www.py" target="_blank" rel="noopener">www.py</a><br> ├─ <strong>init</strong>.py<br> ├─ abc.py<br> └─ xyz.py<br>文件<a href="http://www.py的模块名就是mycompany.web.www，两个文件utils.py的模块名分别是mycompany.utils和mycompany.web.utils。" target="_blank" rel="noopener">www.py的模块名就是mycompany.web.www，两个文件utils.py的模块名分别是mycompany.utils和mycompany.web.utils。</a><br>注意：自己创建模块时要注意命名，不能和Python自带的模块名称冲突。<br>例如，系统自带了sys模块，自己的模块就不可命名为sys.py，否则将无法导入系统自带的sys模块。</p>
<h2 id="文件和异常"><a href="#文件和异常" class="headerlink" title="文件和异常"></a>文件和异常</h2><h3 id="从文件中读取数据"><a href="#从文件中读取数据" class="headerlink" title="从文件中读取数据"></a>从文件中读取数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'pi_digits.txt'</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">		contents = file_object.read()</span><br><span class="line"></span><br><span class="line">	print(contents)</span><br></pre></td></tr></table></figure>
<p>在这里，open(‘pi_digits.txt’)返回一个表示文件pi_digits.txt的对象，<br>Python将这个对象存储在我们将在后面使用的变量中。<br>关键字with在不再需要访问文件后将其关闭(让Python自行处理)。相比于原始文件，该输出唯一不同的地方时末尾多了<br>一个空行。因为read()到达文件末尾时返回一个空字符串，而将这个空字符串显示出来时就是一个空行。<br>要删除多出来的空行，可在print语句中使用rstrip(),即print(contents.rstrip())</p>
<p>逐行读取<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">filename = <span class="string">'pi_digits.txt'</span></span><br><span class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> file_object:</span><br><span class="line">	<span class="keyword">for</span> line <span class="keyword">in</span> file_object:</span><br><span class="line">		print(line)</span><br></pre></td></tr></table></figure></p>
<p>此时打印每一行时，发现空白行更多了。因为在这个文件中，每行的末尾都有一个看不见的换行符，<br>而print语句也会加上一行换行符，因此每行末尾都有两个换行符：一个来自文件，另一个来自print语句。<br>要消除这些多余的空白符，可在print语句中使用rstrip()。<br>Python只能将字符串写入文本文件。要将数值数据存储到文本文件中，<br>必须先使用函数str()将其转换为字符串格式。<br>注意：函数wtite()不会在你写入的文本末尾添加换行符。<br>方法split()以空格为分隔符将字符串分拆成多个部分，并将这些部分都存储到一个列表中。<br>我们将对整篇小说调用split(),再计算得到的列表包含多少个元素，从而确定整篇童话大致包含多少个单词。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">filename = <span class="string">'alice.txt'</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	<span class="keyword">with</span> open(filename) <span class="keyword">as</span> f_obj:</span><br><span class="line">		contents = f_obj.read()</span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">	msg = <span class="string">"Sorry, the file "</span>+filename+<span class="string">" does not exist."</span></span><br><span class="line">	print(msg)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="comment">#计算文件大致包含多少个单词</span></span><br><span class="line">	words=contents.split()</span><br><span class="line">	num_words=len(words)</span><br><span class="line">	print(<span class="string">"The file "</span>+filename +<span class="string">"has about "</span>+str(num_words)+<span class="string">" words."</span>)</span><br></pre></td></tr></table></figure></p>
<p>Python有一个pass语句，可在代码块中使用它来让Python什么都不要做：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_words</span><span class="params">(filename)</span>:</span></span><br><span class="line">	<span class="string">"""计算一个文件大致包含多少个单词"""</span></span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		--snip--</span><br><span class="line">	<span class="keyword">except</span> FileNotfoundError:</span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		--snip--</span><br><span class="line">filename = [<span class="string">'alice.txt'</span>,<span class="string">'siddhartha.txt'</span>,<span class="string">'moby_dick.txt'</span>,<span class="string">'little_women.txt'</span>]</span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">	count_words(filename)</span><br></pre></td></tr></table></figure></p>
<h3 id="JSON模块存储数据"><a href="#JSON模块存储数据" class="headerlink" title="JSON模块存储数据"></a>JSON模块存储数据</h3><p>先编写一个存储一组数字的简短程序，再编写一个将这些数字读取到内存中的程序。<br>第一个程序将使用json.dump()来存储这组数字，而第二个程序将使用json.load()。<br>函数json.dump()接受两个实参：要存储的数据以及可用于存储数据的文件对象。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">username=input(<span class="string">"What is your name?"</span>)</span><br><span class="line">filename=<span class="string">'username.json'</span></span><br><span class="line"><span class="keyword">with</span> open(filename,<span class="string">'w'</span>) <span class="keyword">as</span> f_obj:</span><br><span class="line">	json.dump(username,f_obj)</span><br><span class="line">	print(<span class="string">"We'll remember you when you come back,"</span>+username +<span class="string">"!"</span>)</span><br></pre></td></tr></table></figure></p>
<p>使用json.load()将这个列表读取到内存中：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">filename =<span class="string">'username.json'</span></span><br><span class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> f_obj:</span><br><span class="line">	username=json.load(f_obj)</span><br><span class="line">	print(<span class="string">"Welcome back, "</span>+username+<span class="string">"!"</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p>Python标准库中的模块unittest提供了代码测试工具。单元测试用于核实函数的某个方面没有问题，<br>测试用例是一组单元测试，这些单元测试一起核实函数在各种情形下的行为都符合要求。<br>要为函数编写测试用例，可先导入模块unittest以及要测试的函数，再创建一个继承unittest.TestCase的类，<br>并编写一系列方法对函数行为的不同方面进行测试。<br>以下检查函数get_formatted_name()在给定名和姓时能否正确工作：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> name_function <span class="keyword">import</span> get_formatted_name</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NamesTestCase</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">	<span class="string">"""测试name_function.py"""</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">test_first_last_name</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="string">"""能够正确地处理像Janis Joplin这样的姓名吗?"""</span></span><br><span class="line">		formatted_name=get_formatted_name(<span class="string">'janis'</span>,<span class="string">'joplin'</span>)</span><br><span class="line">		self.assertEqual(formatted_name,<span class="string">'Janis Joplin'</span>)</span><br><span class="line"></span><br><span class="line">unittest.main()</span><br></pre></td></tr></table></figure></p>
<p>首先，我们导入了模块unittest和要测试的函数get_formatted_name()。<br>在此处我们创建了一个名为NameTestCast的类，用于包含一系列针对get_formatted_name()的单元格式。<br>你可随便给这个类命名，但最好让它看起来与要测试的函数相关，并包含字样Test。这个类必须继承<br>unittest.TestCast类，这样Python才知道如何运行你编写的测试。<br>当运行test_name_function.py时，所有以test_打头的方法都将自动运行。<br>代码行unittest.main()让Python运行这个文件中的测试。运行test_name_function.py时，得到的输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">Ran 1 test in 0.000s</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p>
<p>第1行的句点表明有一个测试通过了。接下来的一行指出Python运行了一个测试，消耗的时间不到0.001秒。最后的OK表明该测试用例中<br>的所有单元测试都通过了。<br>测试未通过时结果是什么样的呢？现来修改get_formatted_name()<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_formatted_name</span><span class="params">(first,middle,last)</span>:</span></span><br><span class="line">	<span class="string">"""生成整洁的姓名"""</span></span><br><span class="line">	full_name=first+<span class="string">' '</span>+middle+<span class="string">' '</span>+last</span><br><span class="line">	<span class="keyword">return</span> full_name.title()</span><br></pre></td></tr></table></figure></p>
<p>这次运行程序test_name_function.py时，输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">E</span><br><span class="line">=======================================================</span><br><span class="line">ERROR:test_first_last_name(__main__.NameTestCase)</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">Traceback(most recent call last):</span><br><span class="line">	File &quot;test_name_function.py&quot;,line 8,in test_first_last_name</span><br><span class="line">		formatted_name=get_formatted_name(&apos;janis&apos;,&apos;joplin&apos;)</span><br><span class="line">TypeError:get_formatted_name() missing 1 required positional argument:&apos;last&apos;</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">Ran 1 test in 0.000s</span><br><span class="line">FAILED(errors=1)</span><br></pre></td></tr></table></figure></p>
<p>Python在unittest.TestCase类中提供了很多断言方法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>assertEqual(a,b)</td>
<td>核实a==b</td>
</tr>
<tr>
<td>assertNotequal(a,b)</td>
<td>核实a!=b</td>
</tr>
<tr>
<td>assertTrue(x)</td>
<td>核实x为True</td>
</tr>
<tr>
<td>assertFalse(x)</td>
<td>核实x为False</td>
</tr>
<tr>
<td>assertIn(item,list)</td>
<td>核实item在list中</td>
</tr>
<tr>
<td>assertNotIn(item,list)</td>
<td>核实item不在list中</td>
</tr>
</tbody>
</table>
<p>unittest.TestCase类包含方法setup(),让我们只需创建这些对象一次，并在每个测试方法中使用它们。<br>如果你在TestCase类中包含了方法setup()，Python将先运行它，再运行各个以test_打头的方法。这样，<br>在你编写的每个测试方法中都可使用在方法setUp()中创建的对象了。<br>下面使用setUp()来创建一个调查对象和一组答案，供方法test_store_single_response()和test_store_three_response()使用:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> survey <span class="keyword">import</span> AnonymousSurvey</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestAnonymousSurvey</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">	<span class="string">"""针对AnonymousSurvey类的测试"""</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="string">"""</span></span><br><span class="line"><span class="string">		创建一个调查对象和一组答案，供使用的测试方法使用</span></span><br><span class="line"><span class="string">		"""</span></span><br><span class="line">		question = <span class="string">"What language did you first learn to speak?"</span></span><br><span class="line">		self.my_survey=AnonymousSurvey(question)</span><br><span class="line">		self.responses=[<span class="string">'English'</span>,<span class="string">'Spanish'</span>,<span class="string">'Mandarin'</span>]</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">test_store_single_response</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="string">"""测试单个答案会被妥善地存储"""</span></span><br><span class="line">		self.my_survey.store_response(self.responses[<span class="number">0</span>])</span><br><span class="line">		self.ssertIn(self.responses[<span class="number">0</span>],self.my_survey.responses)</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">test_store_three_response</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="string">"""测试三个答案会被妥善地存储"""</span></span><br><span class="line">		<span class="keyword">for</span> response <span class="keyword">in</span> self.responses:</span><br><span class="line">			self.my_survey.store_response(response)</span><br><span class="line">		<span class="keyword">for</span> response <span class="keyword">in</span> self.responses:</span><br><span class="line">			self.assertIn(response,self.my_survey.responses)</span><br><span class="line"></span><br><span class="line">unittest.main()</span><br></pre></td></tr></table></figure></p>
<p>方法setUp()做了两件事情：创建一个调查对象；创建一个答案列表。存储这两样东西的变量名包含前缀self<br>(即存储在属性中)，因此可在这个类的任何地方使用。<br>注意：运行测试用例时，每完成一个单元测试，Python都打印一个字符：测试通过时打印一个句点；<br>测试引发错误时打印一个E；测试导致断言失败时打印一个F。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">正则表达式</span><br></pre></td></tr></table></figure>
<p>正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; re.match(r&apos;^(\d+)(0*)$&apos;, &apos;102300&apos;).groups()</span><br><span class="line">(&apos;102300&apos;, &apos;&apos;)</span><br></pre></td></tr></table></figure></p>
<p>由于\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了。<br>必须让\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个?就可以让\d+采用非贪婪匹配：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; re.match(r&apos;^(\d+?)(0*)$&apos;, &apos;102300&apos;).groups()</span><br><span class="line">(&apos;1023&apos;, &apos;00&apos;)</span><br></pre></td></tr></table></figure></p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>当我们在Python中使用正则表达式时，re模块内部会干两件事情：<br>编译正则表达式，如果正则表达式的字符串本身不合法，会报错；<br>用编译后的正则表达式去匹配字符串。<br>如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import re</span><br></pre></td></tr></table></figure></p>
<p>编译<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; re_telephone = re.compile(r&apos;^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$&apos;)</span><br></pre></td></tr></table></figure></p>
<p>使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; re_telephone.match(&apos;010-12345&apos;).groups()</span><br><span class="line">(&apos;010&apos;, &apos;12345&apos;)</span><br><span class="line">&gt;&gt;&gt; re_telephone.match(&apos;010-8086&apos;).groups()</span><br><span class="line">(&apos;010&apos;, &apos;8086&apos;)</span><br></pre></td></tr></table></figure></p>
<p>编译后生成Regular Expression对象，由于该对象自己包含了正则表达式，所以调用对应的方法时不用给出正则字符串。</p>
<h2 id="关于引用"><a href="#关于引用" class="headerlink" title="关于引用"></a>关于引用</h2><p>1、简单的赋值不创建副本。<br>2、对 += 或 *= 所做的增量赋值来说，如果左边的变量绑定的是不可变对象，会创建新对象；如果是可变对象，会就地修改。<br>3、为现有的变量赋予新值，不会修改之前绑定的变量。这叫重新绑定：现在变量绑定了其他对象。如果变量是之前那个对象的最后一个引用，对象会被当作垃圾回收。<br>4、函数的参数以别名的形式传递，这意味着，函数可能会修改通过参数传入的可变对象。这一行为无法避免，除非在本地创建副本，或者使用不可变对象（例如，传入元组，而不传入列表）。<br>5、使用可变类型作为函数参数的默认值有危险，因为如果就地修改了参数，默认值也就变了，这会影响以后使用默认值的调用。</p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>赞赏是最好的支持与鼓励！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="dongwj 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="dongwj 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    dongwj
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://dwjie824.github.io/2018/05/28/Hello-Hexo/" title="Python编程基础篇">https://dwjie824.github.io/2018/05/28/Hello-Hexo/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://dwjie824.github.io/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Python/" rel="tag"># Python</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/06/06/Work-Bug/" rel="prev" title="小问题引起的Work Bug">
                小问题引起的Work Bug <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
 		<div id="gitalk-container"></div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/logo.jpg"
                alt="dongwj" />
            
              <p class="site-author-name" itemprop="name">dongwj</p>
              <p class="site-description motion-element" itemprop="description">尝试写作...</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#目前不懂的有：闭包、装饰器和生成器"><span class="nav-number">1.</span> <span class="nav-text">目前不懂的有：闭包、装饰器和生成器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#增删改查"><span class="nav-number">2.</span> <span class="nav-text">增删改查</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#缩进"><span class="nav-number">3.</span> <span class="nav-text">缩进</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#列表"><span class="nav-number">4.</span> <span class="nav-text">列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#切片"><span class="nav-number">5.</span> <span class="nav-text">切片</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对序列使用-和"><span class="nav-number">6.</span> <span class="nav-text">对序列使用+和*</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#元组"><span class="nav-number">7.</span> <span class="nav-text">元组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字典"><span class="nav-number">8.</span> <span class="nav-text">字典</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#列表生成式"><span class="nav-number">9.</span> <span class="nav-text">列表生成式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#嵌套"><span class="nav-number">10.</span> <span class="nav-text">嵌套</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#输入和循环"><span class="nav-number">11.</span> <span class="nav-text">输入和循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用bisect来管理已排序的序列"><span class="nav-number">12.</span> <span class="nav-text">用bisect来管理已排序的序列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#用bisect来搜索"><span class="nav-number">12.1.</span> <span class="nav-text">用bisect来搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用bissect-insort插入新元素"><span class="nav-number">12.2.</span> <span class="nav-text">用bissect.insort插入新元素</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数"><span class="nav-number">13.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#可变参数"><span class="nav-number">13.1.</span> <span class="nav-text">可变参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关键字参数"><span class="nav-number">13.2.</span> <span class="nav-text">关键字参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#命名关键字参数"><span class="nav-number">13.3.</span> <span class="nav-text">命名关键字参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#将函数存储在模块中"><span class="nav-number">13.4.</span> <span class="nav-text">将函数存储在模块中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#高阶函数"><span class="nav-number">13.5.</span> <span class="nav-text">高阶函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map-reduce"><span class="nav-number">13.6.</span> <span class="nav-text">map/reduce</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#filter"><span class="nav-number">13.7.</span> <span class="nav-text">filter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#返回函数-闭包"><span class="nav-number">13.8.</span> <span class="nav-text">返回函数/闭包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#匿名函数-lambda"><span class="nav-number">13.9.</span> <span class="nav-text">匿名函数/lambda</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对yield的总结"><span class="nav-number">13.10.</span> <span class="nav-text">对yield的总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#装饰器"><span class="nav-number">13.11.</span> <span class="nav-text">装饰器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#偏函数"><span class="nav-number">13.12.</span> <span class="nav-text">偏函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类"><span class="nav-number">14.</span> <span class="nav-text">类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用类和实例"><span class="nav-number">14.1.</span> <span class="nav-text">使用类和实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#修改属性的值"><span class="nav-number">14.2.</span> <span class="nav-text">修改属性的值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#继承"><span class="nav-number">14.3.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多态"><span class="nav-number">14.4.</span> <span class="nav-text">多态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#导入类"><span class="nav-number">14.5.</span> <span class="nav-text">导入类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象高级编程"><span class="nav-number">15.</span> <span class="nav-text">面向对象高级编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#slots"><span class="nav-number">15.1.</span> <span class="nav-text">slots</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-property"><span class="nav-number">15.2.</span> <span class="nav-text">使用@property</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#定制类"><span class="nav-number">15.3.</span> <span class="nav-text">定制类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模块"><span class="nav-number">16.</span> <span class="nav-text">模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件和异常"><span class="nav-number">17.</span> <span class="nav-text">文件和异常</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#从文件中读取数据"><span class="nav-number">17.1.</span> <span class="nav-text">从文件中读取数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JSON模块存储数据"><span class="nav-number">17.2.</span> <span class="nav-text">JSON模块存储数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#测试代码"><span class="nav-number">18.</span> <span class="nav-text">测试代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编译"><span class="nav-number">19.</span> <span class="nav-text">编译</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于引用"><span class="nav-number">20.</span> <span class="nav-text">关于引用</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">董不懂工作室</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  
  

          
	  <link rel='stylesheet' href="https://yiyeti.cc/usr/themes/veryse/css/gitalk.css">
      <script src="https://yiyeti.cc/usr/themes/veryse/css/gitalk.min.js"></script>
      <script type="text/javascript">
          var gitalk = new Gitalk({
            clientID:  '', 
            clientSecret: '',
            id: window.location.pathname,
            repo: '', 
            owner: '', 
            admin: '', 
            distractionFreeMode: 'true',
          })
          gitalk.render('gitalk-container')
      </script>
    

  


  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
